<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spring-bean</title>
    <link href="/2024/11/21/bean/"/>
    <url>/2024/11/21/bean/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol><li><strong>基本概念</strong>：Bean是由Spring IoC容器实例化、组装和管理的一个对象，它是Spring应用程序的基本构建块。</li><li><strong>管理范围</strong>：Bean可以是Java对象、组件、服务，或者是应用程序中的任何一个被Spring容器管理的对象。</li></ol><h3 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a><strong>名词介绍</strong></h3><ul><li>实例化：Spring 容器负责实例化 Bean。当应用程序启动时，Spring 容器会根据配置信息或注解扫描的结果，找到并实例化所有被标记为 Bean 的类，并将它们加入容器中。实例化的过程由 Spring 的 IoC 容器负责。</li><li>管理：一旦 Bean 被实例化，Spring 容器将负责管理 Bean 的生命周期和依赖关系。它会根据配置文件或注解的信息，自动解决 Bean 之间的依赖关系，确保在需要的时候正确的注入依赖。Spring 容器还会负责销毁不再需要的 Bean。</li><li>依赖注入：依赖注入是 Spring 框架的一个重要特性，它允许通过自动或显式配置的方式将 Bean 的依赖项注入到其它 Bean 中。依赖注入可以通过构造函数注入、Setter 方法注入或字段注入的方式实现，其中最常见的是使用 ‘@Autowired’注解进行注入。</li><li>作用域：Spring 框架提供了多种作用域（scope）来管理 Bean 的生命周期。常见的作用域包括单例（Singleton）、原型（Prototype）、会话（Session）、请求（Request）等。默认情况下，Bean 是单例的，即每个容器中只存在一个实例。但可以根据需要配置其它作用域。</li><li>自动装配：Spring Boot 支持自动装配（Auto - wiring），它能够根据类型或名称自动解析和注入依赖关系。通过在需要注入的字段、构造函数或 Setter 方法上使用 ‘@Autowired’ 注解，Spring 容器会自动查找并注入对应的 Bean。</li></ul><p>总的来说，Bean 是 Spring 框架中被实例化、管理和维护的对象。通过在类上使用 ‘@Component’ 注解或其派生注解，将一个类声明为 Bean，并将其交给 Spring 容器处理。Spring 容器负责实例化、管理和维护 Bean 的生命周期和依赖关系。通过依赖注入和自动装配，应用程序可以方便的使用和管理 Bean。</p><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><font style="color:#05073b;">自动装配是指Spring框架通过一定的规则，在容器中自动为Bean之间建立依赖关系的过程。在使用自动装配时，开发者无需显式地指定Bean之间的依赖关系，Spring会根据一些配置信息自动将合适的Bean注入到目标Bean中。</font></p><h3 id="Spring-Boot-自动装配的实现"><a href="#Spring-Boot-自动装配的实现" class="headerlink" title="Spring Boot 自动装配的实现"></a>Spring Boot 自动装配的实现</h3><h3 id="核心注解与自动配置机制"><a href="#核心注解与自动配置机制" class="headerlink" title="核心注解与自动配置机制"></a>核心注解与自动配置机制</h3><ol><li><strong>@SpringBootApplication注解</strong>：<ul><li>这是一个组合注解，包含了@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan三个重要注解。</li><li>@SpringBootConfiguration：表明这是一个Spring Boot的配置类。</li><li>@EnableAutoConfiguration：启用Spring Boot的自动配置机制。</li><li>@ComponentScan：启用组件扫描，以便找到带有@Component、@Service、@Repository、@Controller等注解的Spring组件，并将它们注册为Spring Bean。</li></ul></li><li><strong>@EnableAutoConfiguration注解</strong>：<ul><li>触发自动配置机制。</li><li>Spring Boot会根据类路径中的依赖、属性文件中的配置以及其他环境变量来判断并自动配置应用所需的Bean。</li></ul></li></ol><h3 id="二、spring-factories文件与自动配置类"><a href="#二、spring-factories文件与自动配置类" class="headerlink" title="二、spring.factories文件与自动配置类"></a>二、spring.factories文件与自动配置类</h3><ol><li><strong>spring.factories文件</strong>：<ul><li>位于META-INF目录下。</li><li>列出了所有的自动配置类（Auto-Configuration Classes）。</li><li>在Spring应用上下文初始化时，这些自动配置类会被加载，并根据条件自动配置相应的Bean。</li></ul></li><li><strong>自动配置类</strong>：<ul><li>自动配置类通常使用条件注解（Conditional Annotations）来控制Bean的装配。</li><li>常见的条件注解包括：<ul><li>@ConditionalOnClass：只有在指定的类在类路径上存在时才会装配Bean。</li><li>@ConditionalOnMissingBean：只有在指定的Bean不存在时才会装配Bean。</li><li>@ConditionalOnProperty：只有在指定的属性存在并具有特定值时才会装配Bean。</li></ul></li></ul></li></ol><h3 id="三、组件扫描与Bean注册"><a href="#三、组件扫描与Bean注册" class="headerlink" title="三、组件扫描与Bean注册"></a>三、组件扫描与Bean注册</h3><ol><li><strong>组件扫描</strong>：<ul><li>通过@ComponentScan注解启用组件扫描。</li><li>Spring会扫描指定包及其子包中的所有组件（带有@Component、@Service、@Repository、@Controller等注解的类），并将它们注册为Spring Bean。</li></ul></li><li><strong>Bean注册</strong>：<ul><li>在自动配置过程中，Spring Boot会根据检测到的依赖和条件注解来判断是否需要创建和注册Bean。</li><li>如果满足条件，Spring Boot会创建对应的Bean，并将其注册到Spring应用程序上下文中，以供应用程序使用。</li></ul></li></ol><h3 id="四、自定义自动配置"><a href="#四、自定义自动配置" class="headerlink" title="四、自定义自动配置"></a>四、自定义自动配置</h3><p>除了使用Spring Boot提供的自动配置外，开发者还可以自定义自己的自动配置：</p><ol><li>创建一个配置类，并在类上添加@Configuration和@EnableConfigurationProperties注解。</li><li>在配置类中使用条件注解（如@ConditionalOnClass、@ConditionalOnMissingBean等）指定自动配置的条件。</li><li>使用@ConfigurationProperties注解创建配置属性类，并在配置类中注入该属性类。</li><li>编写需要自动配置的Bean，并使用@Bean注解将Bean注册到容器中。</li></ol><p>综上所述，Spring Boot通过核心注解、spring.factories文件、自动配置类、组件扫描与Bean注册以及自定义自动配置等机制和步骤实现了bean的自动装配。这使得开发者可以更加便捷地集成第三方组件和库，并在应用程序中使用它们，而无需手动配置大量的XML文件或Java配置类。</p><h2 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h2><p>注入是指将依赖对象（Bean）的引用或数值注入到目标对象（Bean）中的过程。Spring支持多种注入方式，包括构造器注入、Setter方法注入和字段注入。</p><ol><li><strong>构造器注入（Constructor Injection）</strong>：<ul><li>通过构造方法将依赖对象注入到目标对象中。</li><li>实现方式：在目标对象的构造方法中声明参数，Spring容器负责将依赖对象的实例传递给构造方法。</li><li>优点：确保依赖对象在目标对象创建时即被注入，避免了后续注入可能带来的不确定性。</li></ul></li><li><strong>Setter方法注入（Setter Injection）</strong>：<ul><li>通过Setter方法将依赖对象注入到目标对象中。</li><li>实现方式：在目标对象中提供一个Setter方法，Spring容器负责调用该方法并传递依赖对象的实例。</li><li>优点：灵活性高，可以在目标对象创建后再进行依赖注入。</li></ul></li><li><strong>字段注入（Field Injection）</strong>：<ul><li>通过字段直接将依赖对象注入到目标对象中。</li><li>实现方式：在目标对象中声明一个字段，并使用<code>@Autowired</code>、<code>@Inject</code>等注解标记该字段，Spring容器负责将依赖对象的实例注入该字段。</li><li>优点：简洁明了，减少了代码量。但可能导致测试困难，因为依赖对象在字段声明时即被注入，不易于替换为模拟对象。</li></ul></li></ol><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p> <font style="color:#05073b;">Spring Bean的生命周期是指从Bean的创建到销毁所经历的一系列过程。这个过程由Spring容器进行管理，确保了Bean的实例化和依赖注入等操作的正确执行。</font></p><h3 id="Bean定义"><a href="#Bean定义" class="headerlink" title="Bean定义"></a>Bean定义</h3><ul><li>在Spring配置文件中或通过注解等方式定义Bean，包括Bean的类名、作用域、依赖关系等。</li><li>Spring容器在启动时扫描这些配置，并解析成内部的BeanDefinition对象，<font style="color:#05073b;">该对象包含了Bean的各种定义信息。</font></li></ul><h3 id="Bean实例化"><a href="#Bean实例化" class="headerlink" title="Bean实例化"></a><font style="color:#05073b;">Bean实例化</font></h3><ul><li>对于BeanFactory容器，当用户请求一个尚未初始化的Bean时，容器会调用createBean方法进行实例化。</li><li>对于ApplicationContext容器，在容器启动时就会实例化所有非延迟加载的Bean。</li><li>实例化过程仅仅是创建Bean的实例，并未进行依赖注入和初始化。</li></ul><h3 id="Bean属性赋值"><a href="#Bean属性赋值" class="headerlink" title="Bean属性赋值"></a>Bean属性赋值</h3><ul><li>Spring根据BeanDefinition中的信息，通过反射机制为Bean的属性赋值。</li><li>例如<code>@Autowired</code> 等注解注入的对象、<code>@Value</code> 注入的值、<code>setter</code>方法或构造函数注入依赖和值、<code>@Resource</code>注入的各种资源。</li></ul><h3 id="Bean初始化"><a href="#Bean初始化" class="headerlink" title="Bean初始化"></a>Bean初始化</h3><ol><li><strong>Aware接口回调</strong>：<ul><li>如果Bean实现了xxxAware接口（如BeanNameAware、BeanFactoryAware等），Spring容器会在Bean初始化前后调用相应的set方法，将相关的Aware实例注入给Bean。</li></ul></li><li><strong>BeanPostProcessor前置处理</strong>：<ul><li>在Bean初始化之前，Spring容器会调用实现了BeanPostProcessor接口的类的postProcessBeforeInitialization方法，对Bean进行前置处理。</li></ul></li><li><strong>初始化Bean</strong>：<ul><li>如果Bean实现了InitializingBean接口，Spring容器会调用其afterPropertiesSet方法进行初始化。</li><li>或者，如果Bean在配置中指定了init-method属性，Spring容器会调用该属性指定的方法进行初始化。</li></ul></li><li><strong>BeanPostProcessor后置处理</strong>：<ul><li>在Bean初始化之后，Spring容器会调用实现了BeanPostProcessor接口的类的postProcessAfterInitialization方法，对Bean进行后置处理。</li></ul></li></ol><h3 id="Bean销毁"><a href="#Bean销毁" class="headerlink" title="Bean销毁"></a>Bean销毁</h3><ul><li>对于单例作用域的Bean，Spring容器会负责其整个生命周期的管理。</li><li>当容器关闭时，如果Bean实现了DisposableBean接口，Spring容器会调用其destroy方法进行销毁。</li><li>或者，如果Bean在配置中指定了destroy-method属性，Spring容器会调用该属性指定的方法进行销毁。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/44994284/1729840510674-b48de1a2-b5eb-4b5a-8b0f-9357276e8091.png"></p>]]></content>
    
    
    <categories>
      
      <category>java后端面经</category>
      
      <category>java后端-八股</category>
      
      <category>Spring-面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java后端面经</tag>
      
      <tag>八股</tag>
      
      <tag>Spring-面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基础一</title>
    <link href="/2024/11/21/java-%E5%9F%BA%E7%A1%80%E4%B8%80/"/>
    <url>/2024/11/21/java-%E5%9F%BA%E7%A1%80%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h2><p>标识符是用来表示变量、函数、类等命名实体的名称。它由一系列字符组成，可以包含字母、数字和下划线，并且必须以字母或下划线开头。</p><p>关键字是具有特殊意义的单词。这些单词被保留，不能用作标识符来命名变量、函数或类等。</p><h3 id="java关键字有哪些"><a href="#java关键字有哪些" class="headerlink" title="java关键字有哪些"></a>java关键字有哪些</h3><p>有访问修饰符关键字，如public,private等</p><p>有定义类、接口的关键字，如class，interface</p><p>还有用于控制程序流程和用于声明不同的数据类型的关键字</p><p>还有用于修饰类、方法、属性和变量的关键字等如final，static等</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="java的几种基本数据类型了解吗"><a href="#java的几种基本数据类型了解吗" class="headerlink" title="java的几种基本数据类型了解吗"></a>java的几种基本数据类型了解吗</h3><p>Java 中有 8 种基本数据类型，分别为：</p><ul><li>6 种数字类型：<ul><li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>2 种浮点型：<code>float</code>、<code>double</code></li></ul></li><li>1 种字符类型：<code>char</code></li><li>1 种布尔型：<code>boolean</code>。</li></ul><h3 id="基本类型和包装类型的区别"><a href="#基本类型和包装类型的区别" class="headerlink" title="基本类型和包装类型的区别"></a>基本类型和包装类型的区别</h3><p>基本类型是 Java 中的八种原始数据类型，它们直接存储数据的值， 而包装类型是基本类型的<strong>对象。</strong></p><ul><li>**基本类型的局部变量 存放在 栈 中，直接存储数据值。而未被static修饰的基本类型的成员变量 存放在 堆 中，作为对象的一部分。包装类型是对象，存放在 堆 中， 并且包装类型在使用时会涉及到对象的创建和销毁。  **</li><li>包装类型适合需要对象的场景，比如集合类、反射等；基本类型适合更高效的运算和数据存储。  并且，<strong>包装类型可用于泛型，而基本类型不可以</strong>。</li><li><strong>默认值</strong>：包装类型不赋值就默认为 <code>null</code> ，而基本类型有默认值且不可以是 <code>null</code>。</li><li><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code>** 比较的是值<strong>。对于包装数据类型来说，<code>==</code></strong> 比较的是对象的内存地址**。</li></ul><h3 id="为什么说是几乎所有对象实例都存在于堆中呢？-还有对象存于栈中"><a href="#为什么说是几乎所有对象实例都存在于堆中呢？-还有对象存于栈中" class="headerlink" title="为什么说是几乎所有对象实例都存在于堆中呢？(&#x3D;&gt; 还有对象存于栈中)"></a>为什么说是几乎所有对象实例都存在于堆中呢？(&#x3D;&gt; 还有对象存于栈中)</h3><p>这是因为 HotSpot 虚拟机引入了 JIT(<font style="color:#05073b;">即时编译</font>) 优化之后，会对对象进行逃逸分析，<font style="background-color:#f3bb2f;">（</font><font style="color:#05073b;background-color:#f3bb2f;">确定一个对象是否会在其被分配的方法之外被引用（即“逃逸”），即</font><font style="color:#05073b;background-color:#f3bb2f;">帮助JVM确定一个对象的作用域是否仅限于当前线程和方法调用</font><font style="background-color:#f3bb2f;">）</font>，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换<font style="background-color:#f3bb2f;">（</font><font style="color:#05073b;background-color:#f3bb2f;">当</font><font style="color:#05073b;background-color:#f3bb2f;">逃逸分析确定一个对象不</font><font style="color:#05073b;background-color:#f3bb2f;">会逃逸时，JVM可能会将这个对象分解成一组标量字段，并将这些字段直接在栈上分配，而不是作为一个整体对象在堆上分配。</font><font style="background-color:#f3bb2f;">）</font>来实现栈上分配，而避免堆上分配内存</p><blockquote><p>⚠️ 注意：<strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的存储位置取决于它们的<strong>作用域和声明方式</strong>。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆&#x2F;方法区&#x2F;元空间中。</p></blockquote><h3 id="包装类型的缓存机制了解吗"><a href="#包装类型的缓存机制了解吗" class="headerlink" title="包装类型的缓存机制了解吗"></a>包装类型的缓存机制了解吗</h3><p>包装类型的缓存机制是指Java虚拟机为了优化性能和节省内存，会对一定范围内的包装类型对象进行缓存。当需要这些数值的包装类型对象时，JVM会直接从缓存池中返回已经存在的对象，而不是每次都创建一个新的对象。</p><p>比如<code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类通常缓存了从-128到127之间的数值。，<code>Character</code> 缓存了 <code>[0, 127]</code> 范围的字符  <code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>， 而 <code>Float</code> 和 <code>Double</code> 没有缓存机制，因为它们的数值范围大，缓存效果不明显。  </p><h3 id="自动装箱与拆箱了解吗？原理是什么？"><a href="#自动装箱与拆箱了解吗？原理是什么？" class="headerlink" title="自动装箱与拆箱了解吗？原理是什么？"></a>自动装箱与拆箱了解吗？原理是什么？</h3><p>自动装箱是 Java 自动将基本类型转换为包装类对象的过程；拆箱是将包装类对象转换为基本类型。</p><p><font style="color:#3c3c43;">装箱其实就是调用了 包装类的</font><code>valueOf()</code><font style="color:#3c3c43;">方法，比如 Integer.valueOf()  。拆箱其实就是调用了 </font><code>&lt;font style=&quot;color:#3c3c43;&quot;&gt;xxxValue()&lt;/font&gt;</code><font style="color:#3c3c43;">方法，比如 intValue()  。</font></p><p><font style="color:#3c3c43;"></font></p><h3 id="为什么浮点数运算的时候会有精度丢失的风险？"><a href="#为什么浮点数运算的时候会有精度丢失的风险？" class="headerlink" title="为什么浮点数运算的时候会有精度丢失的风险？"></a>为什么浮点数运算的时候会有精度丢失的风险？</h3><p> 计算机中的浮点数是使用二进制表示的， 无法精确表示所有的小数  ，这就导致了计算时的误差。例如，<code>0.1</code> 在二进制中是一个无限循环的小数，计算机会以有限的位数存储它，从而被截断，产生了微小的误差。而且在浮点数运算过程中，某些结果需要进行舍入。也会导致精度丢失的风险。</p><h3 id="如何解决浮点数运算的精度丢失问题？"><a href="#如何解决浮点数运算的精度丢失问题？" class="headerlink" title="如何解决浮点数运算的精度丢失问题？"></a>如何解决浮点数运算的精度丢失问题？</h3><p>可以使用BigDecimal 类进行浮点数的运算，BigDecimal 提供了任意精度的浮点数运算，可以避免浮点数的精度丢失问题。</p><p>还可以通过将所有的浮点数转换为整数来避免精度丢失。通常做法是将小数转化为<strong>整数</strong>，然后进行运算，最后再转换回小数。  </p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h3><ul><li><strong>语法形式</strong>：从语法形式上看，<strong>成员变量是属于类的</strong>，而<strong>局部变量是在代码块或方法中定义的变量或是方法的参数</strong>；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</li><li><strong>存储方式</strong>：从变量的存储方式来看， 成员变量中的静态变量，存储在堆内存中<strong>，</strong>实例变量存储于方法区中，而<strong>局部变量则存在于栈内存</strong>。</li><li><strong>生存时间</strong>：从变量的生命周期来看， 成员变量随着对象的创建而分配内存，随着对象的销毁而释放内存。  而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li><li><strong>默认值</strong>：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量必须在使用前初始化，JVM 不会为局部变量分配默认值。</li></ul><h3 id="为什么成员变量有默认值？"><a href="#为什么成员变量有默认值？" class="headerlink" title="为什么成员变量有默认值？"></a>为什么成员变量有默认值？</h3><ol><li>默认值避免了未初始化的成员变量存储随机值，从而确保程序运行时的稳定性。  </li><li>对于<strong>成员变量</strong>，它们的初始化可能是在运行时进行的（例如通过构造函数或其他方法），编译器无法在编译时判断是否被初始化。因此，如果不自动赋予默认值，编译器就无法判断这些成员变量是否已被初始化，这可能会导致错误或者不一致的行为。为了避免这种问题，JVM 采用了<strong>自动赋予默认值</strong>的策略。</li></ol><h3 id="静态变量有什么作用？"><a href="#静态变量有什么作用？" class="headerlink" title="静态变量有什么作用？"></a>静态变量有什么作用？</h3><ul><li>静态变量也就是被 <code>static</code> 关键字修饰的变量。 它属于类而不是类的实例。静态变量在类加载时初始化，并且在类的所有实例中共享。 也就是说，不管创建多少个类的实例，静态变量只有一份存储空间。  </li><li>静态变量不依赖于类的实例化，它属于类本身。可以直接通过类名来访问静态变量，而不需要创建类的实例。</li></ul><h3 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别?"></a>字符型常量和字符串常量的区别?</h3><ul><li><strong>形式</strong> : 字符型常量是一个单一的字符，使用单引号 (<code>&#39;</code>) 包裹 。字符串常量是一个字符的序列，使用双引号 (<code>&quot;</code>) 包裹。</li><li><strong>存储方式不同</strong> : 字符型常量在内存中作为 <code>char</code> 类型存储，每个字符占用 2 个字节。字符串常量的数据类型是 <code>String</code> ，它是一个对象类型  ，实际上是一个字符数组， 可以用来表示多个字符。</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员?"></a>静态方法为什么不能调用非静态成员?</h3><p><strong>静态方法</strong>是属于类的，而不是类的实例。在类加载时就可以被调用，无需创建对象。</p><p><strong>非静态成员</strong>是属于对象的。它们在类的实例化时才会被分配内存，意味着非静态成员是属于某个对象实例的。</p><p>当类的静态方法被调用时，对象实例还没有被创建。因此，静态方法调用时，并不能直接访问与某个实例相关的非静态成员，如实例变量和实例方法。 </p><h3 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h3><ul><li><strong>静态方法</strong>属于<strong>类</strong>本身，而不是类的实例。 可以通过类名直接调用，不需要创建类的实例。  </li><li><strong>实例方法</strong>属于<strong>对象实例</strong>，必须在创建对象之后才能使用，且需要通过类的实例来调用，</li><li>静态方法只允许访问静态成员，不允许访问实例成员，而实例方法不存在这个限制。</li><li><strong>静态方法</strong>的生命周期与类的生命周期相关，它在类加载时加载，直到类卸载时销毁。</li><li><strong>实例方法</strong>的生命周期与对象的生命周期相关，只有当对象被创建时，实例方法才会存在，并在对象销毁时随之销毁。</li></ul><h3 id="重载和重写有什么区别？"><a href="#重载和重写有什么区别？" class="headerlink" title="重载和重写有什么区别？"></a>重载和重写有什么区别？</h3><ul><li><strong>重载（Overloading）</strong>指的是在同一个类中，或者父类和子类之间，<strong>方法名相同</strong>，但<strong>参数列表不同</strong>的方法。这是编译时多态的一种体现。  </li><li><strong>重写（Overriding）</strong>指的是在子类中重新定义父类的方法，<strong>方法名、参数列表必须完全相同</strong>。这是运行时多态的一种体现。  </li><li><strong>重载</strong>的访问修饰符没有限制，可以不同。</li><li>而子类<strong>重写</strong>父类方法时，子类的方法的访问权限<strong>不能低于父类方法</strong>。且父类方法访问修饰符为 <code>private/final/static</code> 时，则子类就不能重写该方法</li><li>重载时返回类型可以不同，而重写时返回类型必须与父类相同或是父类的子类。</li><li>构造方法可以重载，但不能被重写。</li></ul><h3 id="什么是可变长参数？"><a href="#什么是可变长参数？" class="headerlink" title="什么是可变长参数？"></a>什么是可变长参数？</h3><p><strong>可变长参数</strong>（Varargs）是 Java 中的一种语法特性，允许在方法中传递<strong>不定数量</strong>的参数。使用可变长参数时，调用者可以传递任意数量的参数，甚至不传递任何参数。编译器会自动将这些参数转换为数组。  </p><p>且可变长参数必须是方法参数列表中的<strong>最后一个参数</strong>。  </p><p><strong>遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？</strong></p><p>答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。</p><p> <font style="color:#3c3c43;">另外，Java 的可变参数编译后实际会被转换成一个数组，我们看编译后生成的</font> <code>class</code><font style="color:#3c3c43;">文件就可以看出来了。</font></p>]]></content>
    
    
    <categories>
      
      <category>java后端面经</category>
      
      <category>java后端-八股</category>
      
      <category>java-面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java后端面经</tag>
      
      <tag>八股</tag>
      
      <tag>java-面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>订单号全局唯一</title>
    <link href="/2024/11/20/%E8%AE%A2%E5%8D%95%E5%8F%B7%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80/"/>
    <url>/2024/11/20/%E8%AE%A2%E5%8D%95%E5%8F%B7%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>12306项目保证订单号全局唯一的解决方案基于雪花算法。</p><p><font style="background-color:rgb(253, 253, 254);">雪花算法是一种分布式ID生成算法。主要功能是在分布式系统中生成全局唯一的ID，并且这些ID是按照时间有序递增的，索引效率高。</font></p><p><font style="background-color:rgb(253, 253, 254);">雪花算法使用一个64位的二进制数字作为ID，这64位被分割成四个部分：</font></p><ol><li><strong><font style="background-color:rgb(253, 253, 254);">符号位（1位）</font></strong><font style="background-color:rgb(253, 253, 254);">：最高位是符号位，始终为0，用于标识ID是正数。</font></li><li><strong><font style="background-color:rgb(253, 253, 254);">时间戳（41位）</font></strong><font style="background-color:rgb(253, 253, 254);">：时间戳41位，精确到毫秒级，可以支持69年。</font></li><li><strong><font style="background-color:rgb(253, 253, 254);">工作机器ID（10位）</font></strong><font style="background-color:rgb(253, 253, 254);">：标识位有10位，可以进一步细分为5位数据中心ID和5位工作机器ID，以支持最多32个数据中心和每个数据中心最多32个工作节点。</font></li><li><strong><font style="background-color:rgb(253, 253, 254);">序列号（12位）</font></strong><font style="background-color:rgb(253, 253, 254);">：序列号占12位，用于标识同一毫秒内生成的不同ID，支持每个节点每毫秒产生4096个唯一的ID。</font></li></ol><p>12306项目中订单ID也是由几个部分拼接而成</p><p>以毫秒为单位获取当前的时间戳，再减去一个固定的起始时间戳，得到ID的时间戳部分</p><p><font style="background-color:rgb(253, 253, 254);">每个节点在生成ID时都会有一个唯一的节点ID，这个节点ID存放在 Redis。节点ID在最终生成的ID中占据固定的位数为5位，最多支持32个不同的节点。</font></p><p>在同一毫秒内生成多个ID时，通过序列号来区分。</p><p>序列号在最终生成的ID中占据固定的位数为7位，意味着每个毫秒内最多可以生成128个不同的ID。</p><p>序列号在每个毫秒开始时重置为0，并在每次调用生成ID方法时递增。如果在同一毫秒内生成的ID数量超过了序列号的最大值，则序列号会循环回到0，并且等待到下一个毫秒再生成新的ID，以避免重复。</p><p>最后拼接订单ID时，</p><p><font style="background-color:rgb(253, 253, 254);">时间戳需要向左移动 12 位来腾出足够的空间存储5位节点ID和7位序列号，节点ID左移7位，通过位或运算（|），可以将左移后的时间戳、节点 ID和序列号组合成一个长整型数值，再在末尾拼接用户ID后六位数，</font></p><p><font style="background-color:rgb(253, 253, 254);">组成了全局唯一订单号。</font></p>]]></content>
    
    
    <categories>
      
      <category>java后端面经</category>
      
      <category>java后端-项目</category>
      
      <category>12306</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java后端面经</tag>
      
      <tag>项目</tag>
      
      <tag>12306</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分库分表</title>
    <link href="/2024/11/20/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <url>/2024/11/20/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="12306为什么要分库分表"><a href="#12306为什么要分库分表" class="headerlink" title="12306为什么要分库分表"></a>12306为什么要分库分表</h2><p><font style="background-color:rgb(253, 253, 254);">12306选择分库分表是为了应对高并发的写入请求和数据量增长带来的挑战，提高系统的写入性能和查询性能。</font></p><ol><li><strong><font style="background-color:rgb(253, 253, 254);">写入压力分散</font></strong><font style="background-color:rgb(253, 253, 254);">：在高并发场景下，单一数据库可能无法承受大量的写入请求，导致性能瓶颈。通过分库，可以将数据按照一定规则拆分到多个数据库中，每个数据库只处理部分数据的写入请求。这样，每个数据库所承受的写入压力被大大降低，从而提高了整体的写入性能。</font></li><li><strong>存储压力分散和提高查询性能</strong>：随着12306项目的数据量的不断增加，单一数据库的存储和查询性能可能逐渐下降。此时，可以将数据按照一定的规则拆分到多个表中，每个表存储部分数据，从而分散数据的存储压力，<font style="background-color:rgb(253, 253, 254);">使每个表的查询范围缩小，</font>提高查询性能。</li></ol><p><strong><font style="color:rgb(5, 7, 59);"></font></strong></p><h2 id="分库分表带来的问题"><a href="#分库分表带来的问题" class="headerlink" title="分库分表带来的问题"></a>分库分表带来的问题</h2><h3 id="读请求扩散问题"><a href="#读请求扩散问题" class="headerlink" title="读请求扩散问题"></a><font style="background-color:rgb(253, 253, 254);">读请求扩散问题</font></h3><p><font style="background-color:rgb(253, 253, 254);">在某些场景下（如用户登录使用电话号码登录），由于无法确定用户的分片键，不知道具体查询哪个数据库，可能导致读请求需要扫描多个数据库或表以查找数据。</font></p><p><font style="background-color:rgb(253, 253, 254);">这将大大增加系统的查询负载和响应时间，严重时可能导致登录超时等问题。</font></p><h3 id="全局唯一性ID问题"><a href="#全局唯一性ID问题" class="headerlink" title="全局唯一性ID问题"></a><font style="background-color:rgb(253, 253, 254);">全局唯一性ID问题</font></h3><p><font style="color:rgb(77, 77, 77);">在之前的单库环境时，对于一张表的主键通常会选用整数型字段，然后通过数据库的自增机制来保证唯一性，但在水平分库多节点的情况时，假设还是以数据库自增机制来维护主键唯一性，可能会导致多个库中出现</font><font style="color:rgb(77, 77, 77);">ID</font><font style="color:rgb(77, 77, 77);">相同、数据不同的情况。</font></p><p><font style="color:rgb(77, 77, 77);"></font></p><h2 id="用户分块分表如何实现"><a href="#用户分块分表如何实现" class="headerlink" title="用户分块分表如何实现"></a>用户分块分表如何实现</h2><h3 id="使用ShardingSphere-JDBC对用户表进行分库分表"><a href="#使用ShardingSphere-JDBC对用户表进行分库分表" class="headerlink" title="使用ShardingSphere-JDBC对用户表进行分库分表"></a>使用ShardingSphere-JDBC对用户表进行分库分表</h3><p><font style="color:rgb(51, 51, 51);">引入 ShardingSphere-JDBC 依赖</font></p><p><font style="color:rgb(51, 51, 51);">在配置文件上定义分片规则后，就可以使用数据库分库分表了。</font></p><p><font style="color:rgb(77, 77, 77);"></font></p><h3 id="综合考虑使用username作为分库分表的分片键"><a href="#综合考虑使用username作为分库分表的分片键" class="headerlink" title="综合考虑使用username作为分库分表的分片键"></a>综合考虑使用username作为分库分表的分片键</h3><p><strong><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">从查询优化来看</font></strong><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">：</font><font style="background-color:rgb(253, 253, 254);">username</font><font style="background-color:rgb(253, 253, 254);">是用户登录和查询个人信息时常用的字段。将其作为分片键，可以使得相关的查询操作能够直接定位到特定的分片上，从而减少了跨分片查询的需求，提高了查询效率。</font></p><p><strong><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">从避免热点数据来看</font></strong><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">：</font><font style="background-color:rgb(253, 253, 254);">username</font>&#96;<font style="background-color:rgb(253, 253, 254);">通常具有唯一性和较高的随机性，这有助于保证数据在各个分片上的均匀分布。这样可以避免出现某个分片上的数据过于集中，导致热点问题和性能瓶颈。</font></p><p><strong><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">从稳定性来看</font></strong><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">：</font><font style="background-color:rgb(253, 253, 254);">一旦选择了分片键，它应该是不可变的。</font><font style="background-color:rgb(253, 253, 254);">username</font>&#96;<font style="background-color:rgb(253, 253, 254);">在用户注册后通常不会发生变化，因此满足这一要求。这保证了分片策略的稳定性和可靠性。</font></p><h3 id="使用分库分表策略对用户表进行拆分"><a href="#使用分库分表策略对用户表进行拆分" class="headerlink" title="使用分库分表策略对用户表进行拆分"></a>使用分库分表策略对用户表进行拆分</h3><ul><li><font style="background-color:rgb(253, 253, 254);">计算用户username的哈希值。</font></li><li><font style="background-color:rgb(253, 253, 254);">使用哈希值对</font><font style="background-color:rgb(253, 253, 254);">sharding-count</font><font style="background-color:rgb(253, 253, 254);">（总分片数）取模，得到一个表分片索引。</font></li><li><font style="background-color:rgb(253, 253, 254);">根据索引选择目标表分片。</font></li><li><font style="background-color:rgb(253, 253, 254);">再除以一个库中分片数，得到要分配库的数字。</font></li></ul><p><font style="background-color:rgb(253, 253, 254);">比如总分片数是32，一个库中分片数是16，可以得到分配的库的数字是0和1，加上前缀就是分到的数据库的名字。</font></p><h2 id="订单号分库分表如何实现"><a href="#订单号分库分表如何实现" class="headerlink" title="订单号分库分表如何实现"></a><font style="color:rgb(77, 77, 77);">订单号分库分表如何实现</font></h2><p>计划订单分库分表的基本查询条件是用户要能查看自己的订单，另外，也要支持订单号精准查询。</p><p><font style="color:rgb(77, 77, 77);">这样的话，就需要按照两个字段当做分片键，这也就意味着每次查询时需要带着用户和订单两个字段，非常的不方便。</font></p><p><font style="color:rgb(77, 77, 77);">因此我们设计一个字段分库分表，查询时有用户id和订单号任意一个就能精准查询，而不导致读扩散问题</font></p><p><font style="color:rgb(77, 77, 77);">这里我们用基因算法解决以上问题。</font></p><p><font style="color:rgb(77, 77, 77);">当我们创建订单号时，将用户id后六位数加在订单号后面，这样订单号和用户id后六位数是一样的，</font></p><p><font style="color:rgb(77, 77, 77);">分库分表的时候，如果SQL字段有用户id，对用户id后六位数取模，得到要分配的</font><font style="background-color:rgb(253, 253, 254);">目标表。</font></p><p><font style="background-color:rgb(253, 253, 254);">如果没有用户id，就用订单号后六位数字取模，得到要分配的目标表。</font></p><p><font style="background-color:rgb(253, 253, 254);">因为</font><font style="color:rgb(77, 77, 77);">订单号和用户id后六位数是一样的，</font><font style="background-color:rgb(253, 253, 254);">查询时， 只要带有任意这两个字段其一，都能根据后六位数找到本人订单分配表的位置</font><font style="color:rgb(77, 77, 77);">。</font></p><p><font style="color:rgb(77, 77, 77);"></font></p><p><strong>乘车人如何查询本人订单</strong></p><p><font style="background-color:rgb(253, 253, 254);">12306系统中，一个账号可以为多人，也就是多位乘车人，购买车票。购票时，乘车人可能还没有12306账号。</font></p><p><font style="background-color:rgb(253, 253, 254);">乘车人注册12306账号后，能够通过“本人车票”功能查看自己出行的车票数据记录。</font></p><p><font style="color:rgb(77, 77, 77);">因为证件号是乘车人唯一标识，因此需要通过乘车人的证件号查询本人订单。</font></p><p><font style="color:rgb(77, 77, 77);">又因为订单表分片键并非证件号ID，直接查找会导致”读请求扩散问题”，因此我们需创建路由表，</font><font style="background-color:rgb(253, 253, 254);">通过证件号绑定订单号。</font></p><p><font style="background-color:rgb(253, 253, 254);">路由表的分库分表规则是按照证件号进行 HASH_MOD 。</font></p><p><font style="background-color:rgb(253, 253, 254);">当乘车人查询本人车票时</font></p><p><font style="background-color:rgb(253, 253, 254);">先按照本人证件号分库分表规则得到要查询的路由表，再根据证件号得到对应的订单号集合，</font></p><p><font style="background-color:rgb(253, 253, 254);">根据订单号，通过基因算法得到分配的订单表和订单明细表。</font></p><p><font style="background-color:rgb(253, 253, 254);">再根据订单号得到订单数据，根据订单号和乘车人证件号得到订单明细数据，最后封装返回这些数据。</font></p><p><font style="color:rgb(77, 77, 77);"></font></p><p><font style="color:rgb(77, 77, 77);"></font></p><p><font style="color:rgb(77, 77, 77);"></font></p><p><font style="color:rgb(77, 77, 77);"></font></p><p><font style="color:rgb(77, 77, 77);"></font></p><p><font style="color:rgb(77, 77, 77);"></font></p><p><font style="color:rgb(77, 77, 77);"></font></p><p><font style="color:rgb(77, 77, 77);"></font></p>]]></content>
    
    
    <categories>
      
      <category>java后端面经</category>
      
      <category>java后端-项目</category>
      
      <category>12306</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java后端面经</tag>
      
      <tag>项目</tag>
      
      <tag>12306</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>缓存一致性的实现</title>
    <link href="/2024/11/20/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/11/20/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p><font style="background-color:rgb(253, 253, 254);">缓存一致性是指缓存中的数据与数据库之间的数据保持一致，确保用户读取到的是最新、最准确的数据。</font></p><p><font style="background-color:rgb(253, 253, 254);">在分布式系统中，由于多个节点可能同时访问和修改数据，因此保证缓存一致性非常重要</font></p><p><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);"></font></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><font style="background-color:rgb(253, 253, 254);">解决方案</font></h2><p><font style="background-color:rgb(253, 253, 254);">当数据更新时，我们最好删除缓存，下一次查询缓存时会出现未命中，这时需要重新读取一次数据库并加载到缓存中，这时缓存中的数据就是最新的数据。</font></p><p><font style="background-color:rgb(253, 253, 254);">如果直接更新缓存可能会涉及复杂的逻辑和额外的开销，影响缓存服务器的性能</font></p><p><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);"></font></p><p><font style="background-color:rgb(253, 253, 254);">如果先删缓存，再更新数据库，可能会出现一些问题：</font></p><p><font style="background-color:rgb(253, 253, 254);">线程A删除缓存后，线程B读取到旧数据并更新到缓存中，而线程A随后更新数据库，导致缓存中存储了旧数据。</font></p><p><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);"></font></p><p>如果先更新数据库再删除缓存，也有可能出现一些问题：</p><p>在线程A更新数据库和删除缓存之间，可能有线程B读取到了缓存中的旧数据。但最终缓存与数据库的数据是一致的，并且都是最新的。</p><p>经过对比可以发现，</p><p>如果先删除缓存，再更新数据库，如果没有及时更新，可能会导致缓存长时间地储存旧数据。对业务影响较大</p><p>而先更新数据库，再删除缓存，只存在一个很小周期的缓存与数据库不一致的情况，因此，对于一致性要求不是很高的业务可以选择先更新数据库，再删除缓存，保证缓存一致性。</p><h2 id="列车余票如何保障缓存数据库一致性"><a href="#列车余票如何保障缓存数据库一致性" class="headerlink" title="列车余票如何保障缓存数据库一致性"></a><font style="color:rgb(38, 38, 38);">列车余票如何保障缓存数据库一致性</font></h2><p>但是先更新数据库，再删除缓存，如果出现删除缓存失败的情况，缓存中储存的还是旧数据，就会出现缓存数据库不一致的情况，并不能保证系统的高可用。</p><p>因此像列车余票扣减这种对一致性敏感的业务，最好还是通过 Binlog 异步更新列车缓存，实现缓存一致性。</p><h3 id="一、利用Binlog异步更新缓存"><a href="#一、利用Binlog异步更新缓存" class="headerlink" title="一、利用Binlog异步更新缓存"></a><font style="background-color:rgb(253, 253, 254);">一、利用Binlog异步更新缓存</font></h3><ol><li><strong><font style="background-color:rgb(253, 253, 254);">Binlog记录数据变更</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li><font style="background-color:rgb(253, 253, 254);">当列车余票数据在数据库中发生变化时（如用户购票导致余票减少），MySQL会将这一变更记录到Binlog日志中。</font></li></ul></li><li><strong><font style="background-color:rgb(253, 253, 254);">Canal监听Binlog</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li><font style="color:rgb(51, 51, 51);">‌Canal是一个基于</font><a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=MySQL&rsv_pq=8ebb7bea0376a922&oq=Canal%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%AD%E9%97%B4%E4%BB%B6&rsv_t=1de1WUCSFGRtk/sivOAxZPZ8SFt+hjnkvhuapaTdWPtY4Qtz3RKHZbG6tWP55a7YZRAKl+6GePK6&tn=39042058_26_oem_dg&ie=utf-8"><font style="color:rgb(51, 51, 51);">MySQL</font></a><font style="color:rgb(51, 51, 51);">增量日志解析的中间件，</font><font style="background-color:rgb(253, 253, 254);">通过监听Binlog的变化，可以实时地解析出Binlog中的数据变更信息。</font></li></ul></li><li><strong><font style="background-color:rgb(253, 253, 254);">异步更新缓存</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li><font style="background-color:rgb(253, 253, 254);">然后Canal将解析出的数据变更信息发送到消息队列中。</font></li><li><font style="background-color:rgb(253, 253, 254);">购票模块中的缓存同步服务 订阅消息队列中的消息，并根据消息中的数据变更信息，异步地更新缓存中的数据。例如，如果数据库中某趟列车的余票减少了，缓存同步服务就会相应地减少缓存中该趟列车的余票数量。</font></li></ul></li></ol><h3 id="二、优势分析"><a href="#二、优势分析" class="headerlink" title="二、优势分析"></a><font style="background-color:rgb(253, 253, 254);">二、优势分析</font></h3><ol><li><strong><font style="background-color:rgb(253, 253, 254);">高可靠性</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li><font style="background-color:rgb(253, 253, 254);">通过消息队列的持久化机制和重试机制，可以确保数据变更信息能够可靠地传递到缓存系统，并成功地更新缓存中的数据。即使缓存更新失败，系统也能够在后续的重试中成功更新。</font></li></ul></li><li><strong><font style="background-color:rgb(253, 253, 254);">实时性高</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li>由于Binlog的写入和监听都是异步进行的，并且这些过程通常具有较高的处理速度，因此可以确保缓存中的数据与数据库中的数据之间的延迟非常小。</li></ul></li><li><strong><font style="background-color:rgb(253, 253, 254);">自动化与减少人为错误</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li><font style="background-color:rgb(253, 253, 254);">因为Binlog更新缓存的过程是自动化的，不需要人工干预或额外的触发机制。这大大减少了由于人为错误或系统延迟导致的缓存更新不及的问题。</font></li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以在对一致性要求不是很高的业务，可以选择先更新数据库，再删除缓存。</p><p>像列车余票扣减这种对一致性敏感的业务，最好还是通过 Binlog 异步更新列车余票缓存，实现缓存一致性。</p>]]></content>
    
    
    <categories>
      
      <category>java后端面经</category>
      
      <category>java后端-项目</category>
      
      <category>12306</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java后端面经</tag>
      
      <tag>项目</tag>
      
      <tag>12306</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双重判定锁解决缓存击穿</title>
    <link href="/2024/11/20/%E5%8F%8C%E9%87%8D%E5%88%A4%E5%AE%9A%E9%94%81%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/"/>
    <url>/2024/11/20/%E5%8F%8C%E9%87%8D%E5%88%A4%E5%AE%9A%E9%94%81%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h2><p>热点数据过期导致大量的请求会同时查询后端数据库。</p><p>对于一个之前从未被请求过的数据，当它第一次被请求时，缓存中没有这个数据，从而导致请求穿透到后端存储。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="设置热点数据永不过期："><a href="#设置热点数据永不过期：" class="headerlink" title="设置热点数据永不过期："></a>设置热点数据永不过期：</h3><p>对于一些热点数据，可以将其设置永不过期</p><p><font style="background-color:rgb(253, 253, 254);">但是这些数据将长期占据缓存空间，可能导致缓存资源无法被有效利用。如果后台数据库中的数据发生变化，而缓存中的数据未能及时更新，就会导致数据不一致的问题。</font></p><h3 id="使用互斥锁："><a href="#使用互斥锁：" class="headerlink" title="使用互斥锁："></a>使用互斥锁：</h3><p>在获取数据时，使用分布式锁（如 Redis 的分布式锁）来控制同时只有一个请求可以去后端获取数据，其他请求需要等待锁释放。这样可以防止多个请求同时穿透到后端存储，有效地避免了缓存击穿问题。</p><p>但还有一个问题就是，假如 有1w 的请求读取一个缓存，只有一个线程会执行逻辑请求数据库并放入缓存。剩下的请求全部在等待获取分布式锁。但即使剩下的请求获取到了锁，还是会继续请求数据库。</p><p>这会对数据库造成无用的性能浪费，因为这 100w 的请求，只有第一次是有效的。</p><p>而且还会造成用户响应时间变长，接口吞吐量下降。</p><p>因此我们可以做双重判断</p><p>获取分布式锁后，在查询数据库之前，<strong>再次检查一下缓存中是否存在数据</strong>。如果缓存中存在数据，说明之前已经有线程将数据库中的数据加载到缓存中了，不需要继续从数据库中读取，直接返回缓存中的数据；如果不存在，才继续执行查询数据库的操作。</p><p>这样不仅<font style="background-color:rgb(253, 253, 254);">减少数据库访问压力，还降低用户响应时间</font></p>]]></content>
    
    
    <categories>
      
      <category>java后端面经</category>
      
      <category>java后端-项目</category>
      
      <category>12306</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java后端面经</tag>
      
      <tag>项目</tag>
      
      <tag>12306</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2024/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p><font style="background-color:rgb(253, 253, 254);">在12306项目中，购票请求的校验逻辑通常可能非常复杂，包含多种不同的验证步骤，如用户身份验证、余额检查、购票数量限制、行程冲突检查等。传统的做法可能是将这些验证逻辑顺序地写在一个大方法中，这样不仅导致代码臃肿、难以维护，而且违反了开闭原则。每次需要添加新的验证步骤时，都需要修改现有的代码。</font></p><p><font style="background-color:rgb(253, 253, 254);">为了解决这个问题，我们可以使用责任链设计模式。责任链模式是一种行为设计模式，它允许你将请求沿着处理者链进行传递。每个处理者都可以对请求进行处理，也可以将请求传递给链中的下一个处理者。这样，你可以在不修改现有代码的情况下添加新的处理步骤，从而提高了代码的扩展性和可维护性。</font></p><p><font style="background-color:rgb(253, 253, 254);">在12306项目中，我们可以将购票验证逻辑拆分成多个独立的验证处理器（Handler），每个处理器负责一种或多种验证逻辑。然后，将这些处理器按照特定的顺序连接起来，形成一个责任链。当用户发起购票请求时，请求会沿着这个责任链进行传递，每个处理器都会根据自己的职责对请求进行验证。</font></p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p><font style="background-color:rgb(253, 253, 254);">在12306项目中，列车余票缓存的更新是通过监听数据库的Binlog变更来实现的。Canal作为中间件，负责将Binlog的变更内容推送到指定的RocketMQ Topic中。而RocketMQ消费者则负责监听这些消息队列，以实时更新列车余票缓存。</font></p><p><font style="background-color:rgb(253, 253, 254);">当需要监听多个表时，为了高效地分发和处理这些Binlog变更数据，12306项目采用了策略模式。</font></p><p><font style="background-color:rgb(253, 253, 254);">对于每个需要监听的表，都实现了一个对应的策略类，这些类实现了策略接口。在每个策略类中，根据表的特点和业务需求，编写了具体的处理逻辑。</font></p><p><font style="background-color:rgb(253, 253, 254);">当Canal将Binlog的变更内容推送到RocketMQ Topic时，相关消费者会监听这些消息。它会根据消息中的表名称，通过策略模式找到对应的策略实现类，并调用其处理方法来处理Binlog变更数据。</font></p><p><font style="background-color:rgb(253, 253, 254);">如果未来需要监听更多的表，只需要添加新的策略类，并实现策略接口中的方法即可。符合开闭原则，提高了代码的可扩展性。</font></p>]]></content>
    
    
    <categories>
      
      <category>java后端面经</category>
      
      <category>java后端-项目</category>
      
      <category>12306</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java后端面经</tag>
      
      <tag>项目</tag>
      
      <tag>12306</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决注册缓存穿透</title>
    <link href="/2024/11/20/%E8%A7%A3%E5%86%B3%E6%B3%A8%E5%86%8C%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/"/>
    <url>/2024/11/20/%E8%A7%A3%E5%86%B3%E6%B3%A8%E5%86%8C%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h2><p><font style="color:rgb(51, 51, 51);">在高并发情况下，可能有大量新用户同时注册，输入的用户名极有可能不存于数据库中，而且这些查询数据库的key也不会被写入缓存，造成每次请求都查不到缓存，直接查询数据库，给数据库造成巨大压力。</font></p><p><font style="color:rgb(51, 51, 51);"></font></p><h2 id="其他解决方案"><a href="#其他解决方案" class="headerlink" title="其他解决方案"></a><font style="color:rgb(51, 51, 51);">其他解决方案</font></h2><h3 id="对不存在的key进行缓存"><a href="#对不存在的key进行缓存" class="headerlink" title="对不存在的key进行缓存"></a><font style="color:rgb(51, 51, 51);">对不存在的key进行缓存</font></h3><p><font style="color:rgb(51, 51, 51);">对不存在的 Key 进行缓存，值设为 Null，并设置短暂过期时间，如 60 秒。</font></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a><font style="color:rgb(51, 51, 51);">问题</font></h4><p><font style="color:rgb(51, 51, 51);">对用户体验不好，假如有一个人注册了a名字，那别人在过期时间都不能注册这名字</font></p><p><font style="color:rgb(51, 51, 51);">而且</font><strong><font style="color:rgb(51, 51, 51);">如果同时有大量并发请求查询不同的名字，数据库还是会秒挂</font></strong></p><p><font style="color:rgb(51, 51, 51);"></font></p><h3 id="Redis-Set-存储已注册用户名"><a href="#Redis-Set-存储已注册用户名" class="headerlink" title=" Redis Set 存储已注册用户名"></a><font style="color:rgb(51, 51, 51);"> Redis Set 存储已注册用户名</font></h3><p><font style="color:rgb(51, 51, 51);">使用确定的数据结构如 Redis 的 Set 集合来存储已注册用户名，判断时检查是否在集合内。</font></p><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a><font style="color:rgb(51, 51, 51);">问题</font></h4><p><font style="color:rgb(51, 51, 51);">永久存储十几亿的用户名到 Redis 缓存中显然不太现实，因为这会</font><strong><font style="color:rgb(51, 51, 51);">占用大量的内存资源。</font></strong></p><p><font style="color:rgb(51, 51, 51);">即使是临时存储，注册用户名还是很有可能在缓存中查询不到数据，</font><strong><font style="color:rgb(51, 51, 51);">仍然无法避免查询数据库的场景。</font></strong></p><p><font style="color:rgb(51, 51, 51);">即使进行分片，也会增加系统的复杂度。</font></p><p><font style="color:rgb(51, 51, 51);">由于该方案占用内存较多且复杂度较高，因此不适合实际应用。</font></p><p><font style="color:rgb(51, 51, 51);"></font></p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a><font style="color:rgb(51, 51, 51);">分布式锁</font></h3><p><font style="color:rgb(51, 51, 51);">针对高并发注册场景，可以先查询缓存，如果不命中则使用分布式锁来保证只有一个线程访问数据库。</font></p><h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a><font style="color:rgb(51, 51, 51);">问题</font></h4><p><font style="color:rgb(51, 51, 51);">虽然一定程度上可以解决缓存穿透问题，但是如果在用户注册高峰期，只有一个线程访问数据库，这可能会导致大量用户的注册请求缓慢或超时，</font><strong><font style="color:rgb(51, 51, 51);">对用户的使用体验来说并不友好。</font></strong></p><p><font style="color:rgb(51, 51, 51);"></font></p><h2 id="12306-解决注册穿透方案"><a href="#12306-解决注册穿透方案" class="headerlink" title="12306 解决注册穿透方案"></a><font style="color:rgb(51, 51, 51);">12306 解决注册穿透方案</font></h2><h3 id="12306如何解决用户注册缓存穿透问题？"><a href="#12306如何解决用户注册缓存穿透问题？" class="headerlink" title="12306如何解决用户注册缓存穿透问题？"></a>12306如何解决用户注册缓存穿透问题？</h3><p><strong><font style="color:rgb(51, 51, 51);">使用布隆过滤器，将所有已注册的用户名存入布隆过滤器，查询时先判断该用户名是否在布隆过滤器中，不在的一定不存在，避免直接查询数据库。</font></strong></p><p><font style="color:rgb(51, 51, 51);">但是如果用户注销了账号，该用户名就可以再次被使用。然而，布隆过滤器由于无法删除元素，因此无法处理这种情况。</font></p><p><font style="color:rgb(51, 51, 51);">为此，我们可以用Redis Set结构储存已注销的用户名。</font></p><p><font style="color:rgb(51, 51, 51);">当其他用户查询用户名是否已被使用时，首先检查布隆过滤器是否包含该用户名。</font></p><p>如果布隆过滤器不存在这个名字，说明未被注册，返回成功</p><p>如果布隆过滤器存在此名字，<font style="color:rgb(51, 51, 51);">进一步检查Redis Set结构中是否包含该用户名。如果有，则代表用户名虽然已被注册但是后来又被注销，可以使用此用户名，返回成功。</font></p><p><font style="color:rgb(51, 51, 51);">如果不存在，则代表该用户名在使用中，尚未注销，因此不可用，返回失败。</font></p><h3 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h3><p><font style="color:rgb(51, 51, 51);">如果用户频繁申请账号再注销，可能导致用户注销可复用的 Username Redis Set 结构变得庞大，增加了存储和查询的负担。</font></p><p><font style="color:rgb(51, 51, 51);">为了防止这种情况，我采取了以下解决方案：</font></p><ol><li><font style="color:rgb(51, 51, 51);">异常行为限制：每次用户注销时，记录用户的证件号，并限制证件号仅可用于注销五次。超过这个限制的次数，将禁止该证件号再次用于注册账号。</font></li><li><font style="color:rgb(51, 51, 51);">缓存分片处理：对Set 结构进行分片，根据用户名的 HashCode 进行取模操作，将数据分散存储在 1024 个 Set 结构中，从而有效防止Redis 大 Key 问题。</font></li></ol>]]></content>
    
    
    <categories>
      
      <category>java后端面经</category>
      
      <category>java后端-项目</category>
      
      <category>12306</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java后端面经</tag>
      
      <tag>项目</tag>
      
      <tag>12306</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>列车检索</title>
    <link href="/2024/11/20/%E5%88%97%E8%BD%A6%E6%A3%80%E7%B4%A2/"/>
    <url>/2024/11/20/%E5%88%97%E8%BD%A6%E6%A3%80%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="车票搜索为什么用Redis而不是ES"><a href="#车票搜索为什么用Redis而不是ES" class="headerlink" title="车票搜索为什么用Redis而不是ES"></a><font style="color:#262626;">车票搜索为什么用Redis而不是ES</font></h2><p>ElasticSearch 是一款非常强大的开源搜索及分析引擎</p><p>而Redis是一个开源的内存数据结构存储系统</p><p>从实时性能来说，Redis 将数据存储在内存中，因此具有极低的读取延迟，可以快速响应实时查询请求。这对于需要即时更新的列车数据非常重要，确保用户能够获取到最新的车票信息。</p><p>从部署成本来说，Redis是一款轻量级的数据库，内存占用相对较低，可以在较小的硬件配置上运行。相比之下，ElasticSearch集群通常需要更多的资源投入，包括更高的硬件配置和更大的存储空间。</p><p>从搜索条件来说，虽然页面上有很多如车次类型、车次席别、出发车站、到达车站等检索条件，但这些都是在前端进行检索的。真正的查询条件只有出发地、目的地和出发日期，而Redis 的数据模型相对简单，这使得 Redis 适合存储一些搜索条件，如出发地、目的地，可以便快速筛选结果。</p><h2 id="有没有提供检索功能，比如北京到杭州，要有北京西到杭州西，北京东到杭州东，北京西到杭州东？"><a href="#有没有提供检索功能，比如北京到杭州，要有北京西到杭州西，北京东到杭州东，北京西到杭州东？" class="headerlink" title="有没有提供检索功能，比如北京到杭州，要有北京西到杭州西，北京东到杭州东，北京西到杭州东？"></a>有没有提供<strong>检索功能</strong>，比如北京到杭州，要有北京西到杭州西，北京东到杭州东，北京西到杭州东？</h2><p>前端传到后端的请求数据是出发城市，到达城市，及出发日期。</p><p>前请求数据先会经过责任链，检查相关数据是否为空或空的字符串，然后检查出发日期是否正确，出发到达地点是否存在</p><ol><li></li></ol><p>缓存中用Hash结构储存了两个城市的所有车次</p><p>key是火车号-出发站点-达到站点，比如1-北京南-杭州东，代表了由北京南站驶向杭州东站的1号火车。</p><p>value是这个车次的具体信息。</p><p>这个Hash结构的key是出发城市-到达城市</p><p>因此我们可以把北京(出发城市)杭州(到达城市)拼接在一起，然后在缓存中找这个Key对应的Hash结构，就能得到所有由北京(出发城市)驶向杭州(到达城市)的车次及车次部分信息。</p><ol start="2"><li></li></ol><p>如果缓存中没有车次集合信息，就要到数据库中找，用双重判定锁保证只有一个线程可以将数据库中相关信息加载到缓存中，避免多次查询给数据库带来巨大压力。</p><p>然后根据出发城市和到达城市，可以在火车站点关联表中查询所有相关的车次集合，</p><p>比如根据北京-杭州，可以得到1号火车-北京南站-杭州东站，3号火车-北京站-杭州站的两个车次。</p><p>然后遍历这个集合，从缓存或数据库中查找相关列车基本信息，并填充到车次集合中。</p><p>最后将这个车次集合加载到缓存中。</p><ol start="3"><li></li></ol><p>接下来就是查询列车余票信息并填充到车次基本信息中。</p><p>因为列车余票数据是实时变更的，如果存储到基本信息中，就没办法变更了，因此要单独存储。</p><p>遍历所有车次。</p><p>先在缓存中查这个车次的所有座位种类及对应的价格的集合</p><p>然后在缓存中找到所有座位种类对应的数量，然后将这个车次的每个座位种类，数量，价格封装成一个类，并加入集合中，然后将这个集合加入到这个车次基本信息中。</p><p>最后返回车次信息集合。</p>]]></content>
    
    
    <categories>
      
      <category>java后端面经</category>
      
      <category>java后端-项目</category>
      
      <category>12306</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java后端面经</tag>
      
      <tag>项目</tag>
      
      <tag>12306</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>令牌桶限流/防超卖</title>
    <link href="/2024/11/20/%E4%BB%A4%E7%89%8C%E6%A1%B6%E9%99%90%E6%B5%81_%E9%98%B2%E8%B6%85%E5%8D%96/"/>
    <url>/2024/11/20/%E4%BB%A4%E7%89%8C%E6%A1%B6%E9%99%90%E6%B5%81_%E9%98%B2%E8%B6%85%E5%8D%96/</url>
    
    <content type="html"><![CDATA[<h2 id="如何保障购票时系统承载高并发而不出问题？"><a href="#如何保障购票时系统承载高并发而不出问题？" class="headerlink" title="如何保障购票时系统承载高并发而不出问题？"></a>如何保障购票时系统承载高并发而不出问题？</h2><p>对于五一、国庆以及过年这些节日来说，一些热门列车的 TPS 少说有几十万 ，很有可能产生瞬时高并发压垮系统的问题，因此必须要对购票服务限流。</p><p><font style="background-color:rgb(253, 253, 254);">最开始计划采用余票缓存来展示余票数量并实现限流效果。这种方式下，系统会将列车余票数据缓存到内存中，以便快速响应前端查询请求。同时，通过缓存中的余票数量来控制购票请求的并发量，避免系统过载。</font></p><p><font style="background-color:rgb(253, 253, 254);">然而，余票缓存做限流也存在一定的风险。特别是在极端情况下，如扣减余票缓存成功后应用宕机，会导致余票缓存和余票数据库库存不一致。这种情况下，前端查询缓存可能会展示余票为0，但数据库实际仍有余票。这种时候，类似于电商的处理，余票为 0 的记录是不允许用户再提交订单的。为了避免用户因余票数量不准确而无法购票，系统需要采取额外的措施来保障购票流程的顺畅。</font></p><p><font style="background-color:rgb(253, 253, 254);">为了解决这个问题，系统引入了令牌桶限流机制。</font></p><p><font style="background-color:rgb(253, 253, 254);">令牌桶限流是一种常用的限流算法，它通过一个令牌容器来存放令牌，每个令牌代表一张列车余票。用户购票时需要先尝试从令牌容器中扣减令牌。如果扣减成功，表示余票数量充足，用户可以继续进行后续的座位分配和订单创建流程；如果扣减失败，则请求被拒绝，避免了对后端数据库的过度压力。</font></p><p><font style="background-color:rgb(253, 253, 254);">为了进一步提高系统的稳定性和可靠性，系统在令牌桶限流的基础上还增加了二次检查机制。当发现没有剩余可用令牌时，系统会触发一个请求去比对数据库是否还有余票。如果数据库有余票，那么系统会将令牌容器缓存删除，并在下一个用户购票时重新加载。</font></p><p><font style="background-color:rgb(253, 253, 254);">如果我们用了令牌遇到上述极端情况，令牌余量为 0，余票缓存余量正常，数据库正常。这个时候，只要余票缓存不为 0，那么哪怕令牌为空，也可以让用户正常下单，进而触发刷新令牌容器的操作。</font></p><p><font style="background-color:rgb(253, 253, 254);">除此之外，在扣减令牌，分配座位成功后，系统会立即将数据库中的座位状态修改为已锁定，防止其他用户同时购买同一个座位。同时，通过Canal数据库变更监听工具，系统会实时监控到座位状态的变更，并更新余票缓存，确保缓存中的余票数据与数据库保持一致。</font></p><h2 id="令牌桶限流如何实现？"><a href="#令牌桶限流如何实现？" class="headerlink" title="令牌桶限流如何实现？"></a>令牌桶限流如何实现？</h2><h3 id="一、令牌桶的初始化和存储"><a href="#一、令牌桶的初始化和存储" class="headerlink" title="一、令牌桶的初始化和存储"></a><font style="background-color:rgb(253, 253, 254);">一、令牌桶的初始化和存储</font></h3><ol><li><strong><font style="background-color:rgb(253, 253, 254);">令牌桶的创建</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li><font style="background-color:rgb(253, 253, 254);">在Redis中创建一个特定结构的Key，用于存储令牌桶的信息。这个Key由车票服务标识、令牌限流容器的标识以及列车ID信息组成。</font></li></ul></li><li><strong><font style="background-color:rgb(253, 253, 254);">令牌桶的存储</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li><font style="background-color:rgb(253, 253, 254);">令牌桶采用 Hash结构， Key 由此列车出发站，终点站以及座位类型组成，对应的 Value 就是列车座位余量。</font></li><li><font style="background-color:rgb(253, 253, 254);">比如id为2的火车对应的令牌桶，有key为北京南_杭州东_0，对应的val为10，代表由北京南驶向杭州东的2号火车的商务座余票量为10，还有key为北京南_南京南_2 ，val为800，代表由北京南驶向南京南的2号火车的二等座余票量为800。</font></li><li><font style="background-color:rgb(253, 253, 254);">而当购买一张票时，还要扣减中间站点以及沿途各站的余量，</font>比如2号火车的行驶路线由北京南站—南京南站—杭州东站 ，如果用户买了北京南站—杭州东站的火车票，同时也要扣减北京南站—南京南站，南京南站—杭州东站的火车票。</li></ul></li></ol><h3 id="二、令牌获取流程"><a href="#二、令牌获取流程" class="headerlink" title="二、令牌获取流程"></a><font style="background-color:rgb(253, 253, 254);">二、令牌获取流程</font></h3><ol><li><strong><font style="background-color:rgb(253, 253, 254);">令牌容器存在性检查</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li><font style="background-color:rgb(253, 253, 254);">在尝试获取令牌之前，系统首先会检查令牌容器是否在Redis中有效。如果令牌容器失效，系统会重新读取并放入缓存。</font></li></ul></li><li><strong><font style="background-color:rgb(253, 253, 254);">准备Lua脚本执行数据</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li><font style="background-color:rgb(253, 253, 254);">然后系统会准备一系列参数，包括存储Redis Hash结构的Key值、用户购买的出发站点和到达站点、需要扣减的相关列车站点以及座位类型和对应数量，这些参数将被传递给Lua脚本。</font></li></ul></li><li><strong><font style="background-color:rgb(253, 253, 254);">执行Lua脚本获取令牌</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li><font style="background-color:rgb(253, 253, 254);">最后，通过客户端调用 Redis 执行 Lua 脚本。判断当前令牌数是否足够满足用户的请求。如果令牌不足，则直接返回失败，如果足够，扣减出发站点和到达站点以及相关的车站令牌余量</font></li></ul></li><li><strong><font style="background-color:rgb(253, 253, 254);">Lua脚本的原子性</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li><font style="background-color:rgb(253, 253, 254);">Lua脚本在Redis中的执行是原子性的，保证了在高并发环境下，令牌桶状态的更新和令牌的获取是安全的。</font></li></ul></li></ol><h2 id="如何防止库存超卖"><a href="#如何防止库存超卖" class="headerlink" title="如何防止库存超卖"></a>如何防止库存超卖</h2><p><font style="background-color:rgb(253, 253, 254);">为了防止库存超卖，系统采取了以下措施：</font></p><ol><li><strong><font style="background-color:rgb(253, 253, 254);">令牌桶限流：</font></strong><ul><li><font style="background-color:rgb(253, 253, 254);">通过令牌桶限流机制，确保只有在获取到令牌的情况下，用户才能继续购票流程。</font></li><li><font style="background-color:rgb(253, 253, 254);">令牌的数量与列车座位余量一一对应，从而避免了超卖的情况。</font></li></ul></li><li><strong><font style="background-color:rgb(253, 253, 254);">订单锁定机制：</font></strong><ul><li><font style="background-color:rgb(253, 253, 254);">在扣减令牌、分配座位成功后，系统会立即将数据库中的座位状态修改为已锁定。</font></li><li><font style="background-color:rgb(253, 253, 254);">这一机制防止了其他用户同时购买同一个座位，从而避免了库存超卖的风险。</font></li></ul></li><li><strong><font style="background-color:rgb(253, 253, 254);">缓存与数据库一致性：</font></strong><ul><li><font style="background-color:rgb(253, 253, 254);">通过Canal数据库变更监听工具，系统能够实时监控座位状态的变更，并更新余票缓存。</font></li><li><font style="background-color:rgb(253, 253, 254);">这确保了缓存中的余票数据与数据库保持一致，避免了因缓存不一致而导致的超卖问题。</font></li></ul></li></ol><p><font style="background-color:rgb(253, 253, 254);">通过令牌桶限流机制、订单锁定机制以及缓存与数据库一致性保障等措施，系统能够有效地防止库存超卖问题，确保购票流程在高并发下的顺畅进行。</font></p><p><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);"></font></p><p><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);"></font></p>]]></content>
    
    
    <categories>
      
      <category>java后端面经</category>
      
      <category>java后端-项目</category>
      
      <category>12306</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java后端面经</tag>
      
      <tag>项目</tag>
      
      <tag>12306</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
