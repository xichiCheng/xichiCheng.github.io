<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>双重判定锁解决缓存击穿</title>
    <link href="/2024/11/20/%E5%8F%8C%E9%87%8D%E5%88%A4%E5%AE%9A%E9%94%81%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/"/>
    <url>/2024/11/20/%E5%8F%8C%E9%87%8D%E5%88%A4%E5%AE%9A%E9%94%81%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h2><p>热点数据过期导致大量的请求会同时查询后端数据库。</p><p>对于一个之前从未被请求过的数据，当它第一次被请求时，缓存中没有这个数据，从而导致请求穿透到后端存储。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="设置热点数据永不过期："><a href="#设置热点数据永不过期：" class="headerlink" title="设置热点数据永不过期："></a>设置热点数据永不过期：</h3><p>对于一些热点数据，可以将其设置永不过期</p><p><font style="background-color:rgb(253, 253, 254);">但是这些数据将长期占据缓存空间，可能导致缓存资源无法被有效利用。如果后台数据库中的数据发生变化，而缓存中的数据未能及时更新，就会导致数据不一致的问题。</font></p><h3 id="使用互斥锁："><a href="#使用互斥锁：" class="headerlink" title="使用互斥锁："></a>使用互斥锁：</h3><p>在获取数据时，使用分布式锁（如 Redis 的分布式锁）来控制同时只有一个请求可以去后端获取数据，其他请求需要等待锁释放。这样可以防止多个请求同时穿透到后端存储，有效地避免了缓存击穿问题。</p><p>但还有一个问题就是，假如 有1w 的请求读取一个缓存，只有一个线程会执行逻辑请求数据库并放入缓存。剩下的请求全部在等待获取分布式锁。但即使剩下的请求获取到了锁，还是会继续请求数据库。</p><p>这会对数据库造成无用的性能浪费，因为这 100w 的请求，只有第一次是有效的。</p><p>而且还会造成用户响应时间变长，接口吞吐量下降。</p><p>因此我们可以做双重判断</p><p>获取分布式锁后，在查询数据库之前，<strong>再次检查一下缓存中是否存在数据</strong>。如果缓存中存在数据，说明之前已经有线程将数据库中的数据加载到缓存中了，不需要继续从数据库中读取，直接返回缓存中的数据；如果不存在，才继续执行查询数据库的操作。</p><p>这样不仅<font style="background-color:rgb(253, 253, 254);">减少数据库访问压力，还降低用户响应时间</font></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>解决注册缓存穿透</title>
    <link href="/2024/11/20/%E8%A7%A3%E5%86%B3%E6%B3%A8%E5%86%8C%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/"/>
    <url>/2024/11/20/%E8%A7%A3%E5%86%B3%E6%B3%A8%E5%86%8C%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h2><p><font style="color:rgb(51, 51, 51);">在高并发情况下，可能有大量新用户同时注册，输入的用户名极有可能不存于数据库中，而且这些查询数据库的key也不会被写入缓存，造成每次请求都查不到缓存，直接查询数据库，给数据库造成巨大压力。</font></p><p><font style="color:rgb(51, 51, 51);"></font></p><h2 id="其他解决方案"><a href="#其他解决方案" class="headerlink" title="其他解决方案"></a><font style="color:rgb(51, 51, 51);">其他解决方案</font></h2><h3 id="对不存在的key进行缓存"><a href="#对不存在的key进行缓存" class="headerlink" title="对不存在的key进行缓存"></a><font style="color:rgb(51, 51, 51);">对不存在的key进行缓存</font></h3><p><font style="color:rgb(51, 51, 51);">对不存在的 Key 进行缓存，值设为 Null，并设置短暂过期时间，如 60 秒。</font></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a><font style="color:rgb(51, 51, 51);">问题</font></h4><p><font style="color:rgb(51, 51, 51);">对用户体验不好，假如有一个人注册了a名字，那别人在过期时间都不能注册这名字</font></p><p><font style="color:rgb(51, 51, 51);">而且</font><strong><font style="color:rgb(51, 51, 51);">如果同时有大量并发请求查询不同的名字，数据库还是会秒挂</font></strong></p><p><font style="color:rgb(51, 51, 51);"></font></p><h3 id="Redis-Set-存储已注册用户名"><a href="#Redis-Set-存储已注册用户名" class="headerlink" title=" Redis Set 存储已注册用户名"></a><font style="color:rgb(51, 51, 51);"> Redis Set 存储已注册用户名</font></h3><p><font style="color:rgb(51, 51, 51);">使用确定的数据结构如 Redis 的 Set 集合来存储已注册用户名，判断时检查是否在集合内。</font></p><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a><font style="color:rgb(51, 51, 51);">问题</font></h4><p><font style="color:rgb(51, 51, 51);">永久存储十几亿的用户名到 Redis 缓存中显然不太现实，因为这会</font><strong><font style="color:rgb(51, 51, 51);">占用大量的内存资源。</font></strong></p><p><font style="color:rgb(51, 51, 51);">即使是临时存储，注册用户名还是很有可能在缓存中查询不到数据，</font><strong><font style="color:rgb(51, 51, 51);">仍然无法避免查询数据库的场景。</font></strong></p><p><font style="color:rgb(51, 51, 51);">即使进行分片，也会增加系统的复杂度。</font></p><p><font style="color:rgb(51, 51, 51);">由于该方案占用内存较多且复杂度较高，因此不适合实际应用。</font></p><p><font style="color:rgb(51, 51, 51);"></font></p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a><font style="color:rgb(51, 51, 51);">分布式锁</font></h3><p><font style="color:rgb(51, 51, 51);">针对高并发注册场景，可以先查询缓存，如果不命中则使用分布式锁来保证只有一个线程访问数据库。</font></p><h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a><font style="color:rgb(51, 51, 51);">问题</font></h4><p><font style="color:rgb(51, 51, 51);">虽然一定程度上可以解决缓存穿透问题，但是如果在用户注册高峰期，只有一个线程访问数据库，这可能会导致大量用户的注册请求缓慢或超时，</font><strong><font style="color:rgb(51, 51, 51);">对用户的使用体验来说并不友好。</font></strong></p><p><font style="color:rgb(51, 51, 51);"></font></p><h2 id="12306-解决注册穿透方案"><a href="#12306-解决注册穿透方案" class="headerlink" title="12306 解决注册穿透方案"></a><font style="color:rgb(51, 51, 51);">12306 解决注册穿透方案</font></h2><h3 id="12306如何解决用户注册缓存穿透问题？"><a href="#12306如何解决用户注册缓存穿透问题？" class="headerlink" title="12306如何解决用户注册缓存穿透问题？"></a>12306如何解决用户注册缓存穿透问题？</h3><p><strong><font style="color:rgb(51, 51, 51);">使用布隆过滤器，将所有已注册的用户名存入布隆过滤器，查询时先判断该用户名是否在布隆过滤器中，不在的一定不存在，避免直接查询数据库。</font></strong></p><p><font style="color:rgb(51, 51, 51);">但是如果用户注销了账号，该用户名就可以再次被使用。然而，布隆过滤器由于无法删除元素，因此无法处理这种情况。</font></p><p><font style="color:rgb(51, 51, 51);">为此，我们可以用Redis Set结构储存已注销的用户名。</font></p><p><font style="color:rgb(51, 51, 51);">当其他用户查询用户名是否已被使用时，首先检查布隆过滤器是否包含该用户名。</font></p><p>如果布隆过滤器不存在这个名字，说明未被注册，返回成功</p><p>如果布隆过滤器存在此名字，<font style="color:rgb(51, 51, 51);">进一步检查Redis Set结构中是否包含该用户名。如果有，则代表用户名虽然已被注册但是后来又被注销，可以使用此用户名，返回成功。</font></p><p><font style="color:rgb(51, 51, 51);">如果不存在，则代表该用户名在使用中，尚未注销，因此不可用，返回失败。</font></p><h3 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h3><p><font style="color:rgb(51, 51, 51);">如果用户频繁申请账号再注销，可能导致用户注销可复用的 Username Redis Set 结构变得庞大，增加了存储和查询的负担。</font></p><p><font style="color:rgb(51, 51, 51);">为了防止这种情况，我采取了以下解决方案：</font></p><ol><li><font style="color:rgb(51, 51, 51);">异常行为限制：每次用户注销时，记录用户的证件号，并限制证件号仅可用于注销五次。超过这个限制的次数，将禁止该证件号再次用于注册账号。</font></li><li><font style="color:rgb(51, 51, 51);">缓存分片处理：对Set 结构进行分片，根据用户名的 HashCode 进行取模操作，将数据分散存储在 1024 个 Set 结构中，从而有效防止Redis 大 Key 问题。</font></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2024/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p><font style="background-color:rgb(253, 253, 254);">在12306项目中，购票请求的校验逻辑通常可能非常复杂，包含多种不同的验证步骤，如用户身份验证、余额检查、购票数量限制、行程冲突检查等。传统的做法可能是将这些验证逻辑顺序地写在一个大方法中，这样不仅导致代码臃肿、难以维护，而且违反了开闭原则。每次需要添加新的验证步骤时，都需要修改现有的代码。</font></p><p><font style="background-color:rgb(253, 253, 254);">为了解决这个问题，我们可以使用责任链设计模式。责任链模式是一种行为设计模式，它允许你将请求沿着处理者链进行传递。每个处理者都可以对请求进行处理，也可以将请求传递给链中的下一个处理者。这样，你可以在不修改现有代码的情况下添加新的处理步骤，从而提高了代码的扩展性和可维护性。</font></p><p><font style="background-color:rgb(253, 253, 254);">在12306项目中，我们可以将购票验证逻辑拆分成多个独立的验证处理器（Handler），每个处理器负责一种或多种验证逻辑。然后，将这些处理器按照特定的顺序连接起来，形成一个责任链。当用户发起购票请求时，请求会沿着这个责任链进行传递，每个处理器都会根据自己的职责对请求进行验证。</font></p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p><font style="background-color:rgb(253, 253, 254);">在12306项目中，列车余票缓存的更新是通过监听数据库的Binlog变更来实现的。Canal作为中间件，负责将Binlog的变更内容推送到指定的RocketMQ Topic中。而RocketMQ消费者则负责监听这些消息队列，以实时更新列车余票缓存。</font></p><p><font style="background-color:rgb(253, 253, 254);">当需要监听多个表时，为了高效地分发和处理这些Binlog变更数据，12306项目采用了策略模式。</font></p><p><font style="background-color:rgb(253, 253, 254);">对于每个需要监听的表，都实现了一个对应的策略类，这些类实现了策略接口。在每个策略类中，根据表的特点和业务需求，编写了具体的处理逻辑。</font></p><p><font style="background-color:rgb(253, 253, 254);">当Canal将Binlog的变更内容推送到RocketMQ Topic时，相关消费者会监听这些消息。它会根据消息中的表名称，通过策略模式找到对应的策略实现类，并调用其处理方法来处理Binlog变更数据。</font></p><p><font style="background-color:rgb(253, 253, 254);">如果未来需要监听更多的表，只需要添加新的策略类，并实现策略接口中的方法即可。符合开闭原则，提高了代码的可扩展性。</font></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>列车检索</title>
    <link href="/2024/11/20/%E5%88%97%E8%BD%A6%E6%A3%80%E7%B4%A2/"/>
    <url>/2024/11/20/%E5%88%97%E8%BD%A6%E6%A3%80%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="车票搜索为什么用Redis而不是ES"><a href="#车票搜索为什么用Redis而不是ES" class="headerlink" title="车票搜索为什么用Redis而不是ES"></a><font style="color:#262626;">车票搜索为什么用Redis而不是ES</font></h2><p>ElasticSearch 是一款非常强大的开源搜索及分析引擎</p><p>而Redis是一个开源的内存数据结构存储系统</p><p>从实时性能来说，Redis 将数据存储在内存中，因此具有极低的读取延迟，可以快速响应实时查询请求。这对于需要即时更新的列车数据非常重要，确保用户能够获取到最新的车票信息。</p><p>从部署成本来说，Redis是一款轻量级的数据库，内存占用相对较低，可以在较小的硬件配置上运行。相比之下，ElasticSearch集群通常需要更多的资源投入，包括更高的硬件配置和更大的存储空间。</p><p>从搜索条件来说，虽然页面上有很多如车次类型、车次席别、出发车站、到达车站等检索条件，但这些都是在前端进行检索的。真正的查询条件只有出发地、目的地和出发日期，而Redis 的数据模型相对简单，这使得 Redis 适合存储一些搜索条件，如出发地、目的地，可以便快速筛选结果。</p><h2 id="有没有提供检索功能，比如北京到杭州，要有北京西到杭州西，北京东到杭州东，北京西到杭州东？"><a href="#有没有提供检索功能，比如北京到杭州，要有北京西到杭州西，北京东到杭州东，北京西到杭州东？" class="headerlink" title="有没有提供检索功能，比如北京到杭州，要有北京西到杭州西，北京东到杭州东，北京西到杭州东？"></a>有没有提供<strong>检索功能</strong>，比如北京到杭州，要有北京西到杭州西，北京东到杭州东，北京西到杭州东？</h2><p>前端传到后端的请求数据是出发城市，到达城市，及出发日期。</p><p>前请求数据先会经过责任链，检查相关数据是否为空或空的字符串，然后检查出发日期是否正确，出发到达地点是否存在</p><ol><li></li></ol><p>缓存中用Hash结构储存了两个城市的所有车次</p><p>key是火车号-出发站点-达到站点，比如1-北京南-杭州东，代表了由北京南站驶向杭州东站的1号火车。</p><p>value是这个车次的具体信息。</p><p>这个Hash结构的key是出发城市-到达城市</p><p>因此我们可以把北京(出发城市)杭州(到达城市)拼接在一起，然后在缓存中找这个Key对应的Hash结构，就能得到所有由北京(出发城市)驶向杭州(到达城市)的车次及车次部分信息。</p><ol start="2"><li></li></ol><p>如果缓存中没有车次集合信息，就要到数据库中找，用双重判定锁保证只有一个线程可以将数据库中相关信息加载到缓存中，避免多次查询给数据库带来巨大压力。</p><p>然后根据出发城市和到达城市，可以在火车站点关联表中查询所有相关的车次集合，</p><p>比如根据北京-杭州，可以得到1号火车-北京南站-杭州东站，3号火车-北京站-杭州站的两个车次。</p><p>然后遍历这个集合，从缓存或数据库中查找相关列车基本信息，并填充到车次集合中。</p><p>最后将这个车次集合加载到缓存中。</p><ol start="3"><li></li></ol><p>接下来就是查询列车余票信息并填充到车次基本信息中。</p><p>因为列车余票数据是实时变更的，如果存储到基本信息中，就没办法变更了，因此要单独存储。</p><p>遍历所有车次。</p><p>先在缓存中查这个车次的所有座位种类及对应的价格的集合</p><p>然后在缓存中找到所有座位种类对应的数量，然后将这个车次的每个座位种类，数量，价格封装成一个类，并加入集合中，然后将这个集合加入到这个车次基本信息中。</p><p>最后返回车次信息集合。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>令牌桶限流/防超卖</title>
    <link href="/2024/11/20/%E4%BB%A4%E7%89%8C%E6%A1%B6%E9%99%90%E6%B5%81_%E9%98%B2%E8%B6%85%E5%8D%96/"/>
    <url>/2024/11/20/%E4%BB%A4%E7%89%8C%E6%A1%B6%E9%99%90%E6%B5%81_%E9%98%B2%E8%B6%85%E5%8D%96/</url>
    
    <content type="html"><![CDATA[<h2 id="如何保障购票时系统承载高并发而不出问题？"><a href="#如何保障购票时系统承载高并发而不出问题？" class="headerlink" title="如何保障购票时系统承载高并发而不出问题？"></a>如何保障购票时系统承载高并发而不出问题？</h2><p>对于五一、国庆以及过年这些节日来说，一些热门列车的 TPS 少说有几十万 ，很有可能产生瞬时高并发压垮系统的问题，因此必须要对购票服务限流。</p><p><font style="background-color:rgb(253, 253, 254);">最开始计划采用余票缓存来展示余票数量并实现限流效果。这种方式下，系统会将列车余票数据缓存到内存中，以便快速响应前端查询请求。同时，通过缓存中的余票数量来控制购票请求的并发量，避免系统过载。</font></p><p><font style="background-color:rgb(253, 253, 254);">然而，余票缓存做限流也存在一定的风险。特别是在极端情况下，如扣减余票缓存成功后应用宕机，会导致余票缓存和余票数据库库存不一致。这种情况下，前端查询缓存可能会展示余票为0，但数据库实际仍有余票。这种时候，类似于电商的处理，余票为 0 的记录是不允许用户再提交订单的。为了避免用户因余票数量不准确而无法购票，系统需要采取额外的措施来保障购票流程的顺畅。</font></p><p><font style="background-color:rgb(253, 253, 254);">为了解决这个问题，系统引入了令牌桶限流机制。</font></p><p><font style="background-color:rgb(253, 253, 254);">令牌桶限流是一种常用的限流算法，它通过一个令牌容器来存放令牌，每个令牌代表一张列车余票。用户购票时需要先尝试从令牌容器中扣减令牌。如果扣减成功，表示余票数量充足，用户可以继续进行后续的座位分配和订单创建流程；如果扣减失败，则请求被拒绝，避免了对后端数据库的过度压力。</font></p><p><font style="background-color:rgb(253, 253, 254);">为了进一步提高系统的稳定性和可靠性，系统在令牌桶限流的基础上还增加了二次检查机制。当发现没有剩余可用令牌时，系统会触发一个请求去比对数据库是否还有余票。如果数据库有余票，那么系统会将令牌容器缓存删除，并在下一个用户购票时重新加载。</font></p><p><font style="background-color:rgb(253, 253, 254);">如果我们用了令牌遇到上述极端情况，令牌余量为 0，余票缓存余量正常，数据库正常。这个时候，只要余票缓存不为 0，那么哪怕令牌为空，也可以让用户正常下单，进而触发刷新令牌容器的操作。</font></p><p><font style="background-color:rgb(253, 253, 254);">除此之外，在扣减令牌，分配座位成功后，系统会立即将数据库中的座位状态修改为已锁定，防止其他用户同时购买同一个座位。同时，通过Canal数据库变更监听工具，系统会实时监控到座位状态的变更，并更新余票缓存，确保缓存中的余票数据与数据库保持一致。</font></p><h2 id="令牌桶限流如何实现？"><a href="#令牌桶限流如何实现？" class="headerlink" title="令牌桶限流如何实现？"></a>令牌桶限流如何实现？</h2><h3 id="一、令牌桶的初始化和存储"><a href="#一、令牌桶的初始化和存储" class="headerlink" title="一、令牌桶的初始化和存储"></a><font style="background-color:rgb(253, 253, 254);">一、令牌桶的初始化和存储</font></h3><ol><li><strong><font style="background-color:rgb(253, 253, 254);">令牌桶的创建</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li><font style="background-color:rgb(253, 253, 254);">在Redis中创建一个特定结构的Key，用于存储令牌桶的信息。这个Key由车票服务标识、令牌限流容器的标识以及列车ID信息组成。</font></li></ul></li><li><strong><font style="background-color:rgb(253, 253, 254);">令牌桶的存储</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li><font style="background-color:rgb(253, 253, 254);">令牌桶采用 Hash结构， Key 由此列车出发站，终点站以及座位类型组成，对应的 Value 就是列车座位余量。</font></li><li><font style="background-color:rgb(253, 253, 254);">比如id为2的火车对应的令牌桶，有key为北京南_杭州东_0，对应的val为10，代表由北京南驶向杭州东的2号火车的商务座余票量为10，还有key为北京南_南京南_2 ，val为800，代表由北京南驶向南京南的2号火车的二等座余票量为800。</font></li><li><font style="background-color:rgb(253, 253, 254);">而当购买一张票时，还要扣减中间站点以及沿途各站的余量，</font>比如2号火车的行驶路线由北京南站—南京南站—杭州东站 ，如果用户买了北京南站—杭州东站的火车票，同时也要扣减北京南站—南京南站，南京南站—杭州东站的火车票。</li></ul></li></ol><h3 id="二、令牌获取流程"><a href="#二、令牌获取流程" class="headerlink" title="二、令牌获取流程"></a><font style="background-color:rgb(253, 253, 254);">二、令牌获取流程</font></h3><ol><li><strong><font style="background-color:rgb(253, 253, 254);">令牌容器存在性检查</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li><font style="background-color:rgb(253, 253, 254);">在尝试获取令牌之前，系统首先会检查令牌容器是否在Redis中有效。如果令牌容器失效，系统会重新读取并放入缓存。</font></li></ul></li><li><strong><font style="background-color:rgb(253, 253, 254);">准备Lua脚本执行数据</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li><font style="background-color:rgb(253, 253, 254);">然后系统会准备一系列参数，包括存储Redis Hash结构的Key值、用户购买的出发站点和到达站点、需要扣减的相关列车站点以及座位类型和对应数量，这些参数将被传递给Lua脚本。</font></li></ul></li><li><strong><font style="background-color:rgb(253, 253, 254);">执行Lua脚本获取令牌</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li><font style="background-color:rgb(253, 253, 254);">最后，通过客户端调用 Redis 执行 Lua 脚本。判断当前令牌数是否足够满足用户的请求。如果令牌不足，则直接返回失败，如果足够，扣减出发站点和到达站点以及相关的车站令牌余量</font></li></ul></li><li><strong><font style="background-color:rgb(253, 253, 254);">Lua脚本的原子性</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li><font style="background-color:rgb(253, 253, 254);">Lua脚本在Redis中的执行是原子性的，保证了在高并发环境下，令牌桶状态的更新和令牌的获取是安全的。</font></li></ul></li></ol><h2 id="如何防止库存超卖"><a href="#如何防止库存超卖" class="headerlink" title="如何防止库存超卖"></a>如何防止库存超卖</h2><p><font style="background-color:rgb(253, 253, 254);">为了防止库存超卖，系统采取了以下措施：</font></p><h4 id="令牌桶限流："><a href="#令牌桶限流：" class="headerlink" title="令牌桶限流："></a><font style="background-color:rgb(253, 253, 254);">令牌桶限流：</font></h4><pre><code class="hljs">- &lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;通过令牌桶限流机制，确保只有在获取到令牌的情况下，用户才能继续购票流程。&lt;/font&gt;- &lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;令牌的数量与列车座位余量一一对应，从而避免了超卖的情况。&lt;/font&gt;</code></pre><h4 id="订单锁定机制："><a href="#订单锁定机制：" class="headerlink" title="订单锁定机制："></a><font style="background-color:rgb(253, 253, 254);">订单锁定机制：</font></h4><pre><code class="hljs">- &lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;在扣减令牌、分配座位成功后，系统会立即将数据库中的座位状态修改为已锁定。&lt;/font&gt;- &lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;这一机制防止了其他用户同时购买同一个座位，从而避免了库存超卖的风险。&lt;/font&gt;</code></pre><h4 id="缓存与数据库一致性："><a href="#缓存与数据库一致性：" class="headerlink" title="缓存与数据库一致性："></a><font style="background-color:rgb(253, 253, 254);">缓存与数据库一致性：</font></h4><pre><code class="hljs">- &lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;通过Canal数据库变更监听工具，系统能够实时监控座位状态的变更，并更新余票缓存。&lt;/font&gt;- &lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;这确保了缓存中的余票数据与数据库保持一致，避免了因缓存不一致而导致的超卖问题。&lt;/font&gt;</code></pre><p><font style="background-color:rgb(253, 253, 254);">通过令牌桶限流机制、订单锁定机制以及缓存与数据库一致性保障等措施，系统能够有效地防止库存超卖问题，确保购票流程在高并发下的顺畅进行。</font></p><p><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);"></font></p><p><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);"></font></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
