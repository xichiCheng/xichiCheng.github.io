<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>java基础二</title>
    <link href="/2024/11/23/java-%E5%9F%BA%E7%A1%80%E4%BA%8C/"/>
    <url>/2024/11/23/java-%E5%9F%BA%E7%A1%80%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><p>面向过程编程（Procedural-Oriented Programming，POP）和面向对象编程（Object-Oriented Programming，OOP）是两种常见的编程范式。</p><ul><li><strong><font style="color:rgb(51, 51, 51);">面向过程（POP）</font></strong><font style="color:rgb(51, 51, 51);">：是一种以过程为中心的编程思想，主要关注</font><strong><font style="color:rgb(51, 51, 51);">问题解决的步骤和流程</font></strong><font style="color:rgb(51, 51, 51);">。它将问题分解成一系列详细的步骤，然后通过函数实现这些步骤，并依次调用这些函数来解决问题。</font></li><li><strong><font style="color:rgb(51, 51, 51);">面向对象（OOP）</font></strong><font style="color:rgb(51, 51, 51);">：是一类以对象作为基本程序结构单位的编程范式。它强调以</font><strong><font style="color:rgb(51, 51, 51);">对象为核心</font></strong><font style="color:rgb(51, 51, 51);">，通过创建和使用对象来模拟现实世界中的实体和它们之间的关系。面向对象编程关注问题的本质和对象之间的交互。</font></li></ul><p>相比较于 POP，OOP 开发的程序一般具有下面这些优点：</p><ul><li><strong>易维护</strong>：由于良好的结构和封装性，OOP 程序通常更容易维护。</li><li><strong>易复用</strong>：通过继承和多态，OOP 设计使得代码更具复用性，方便扩展功能。</li><li><strong>易扩展</strong>：模块化设计使得系统扩展变得更加容易和灵活。</li></ul><h3 id="创建一个对象用什么运算符"><a href="#创建一个对象用什么运算符" class="headerlink" title="创建一个对象用什么运算符"></a>创建一个对象用什么运算符</h3><p><font style="background-color:rgb(253, 253, 254);">在 Java 中，创建对象使用 </font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;new&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);"> 运算符。</font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;new&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);"> 运算符首先在</font><strong>堆内存</strong><font style="background-color:rgb(253, 253, 254);">中为对象实例分配空间。  然后</font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;new&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);"> 运算符会调用相应类的构造函数，来初始化对象的状态，最后</font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;new&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);"> 运算符返回堆内存中对象的</font><strong>引用</strong><font style="background-color:rgb(253, 253, 254);">（即内存地址）。这个引用在栈内存中 ，指向创建的对象，使得程序可以通过这个引用访问该对象的数据和行为。  </font></p><h3 id="对象实体与对象引用有何不同"><a href="#对象实体与对象引用有何不同" class="headerlink" title="对象实体与对象引用有何不同"></a>对象实体与对象引用有何不同</h3><ul><li><strong>对象实体</strong>是通过 <code>new</code> 运算符创建的实际对象，它存储了对象的属性（字段）和行为（方法）。</li><li><strong>对象引用</strong>是一个变量，它储存了指向堆内存中对象实体的<strong>地址</strong>。是一个引用类型变量，并不直接存储对象的实际数据，而是存储了对象在堆内存中的地址。通过对象引用，程序可以访问和操作该对象的状态。</li><li>对象实体位于<strong>堆内存</strong>中 ， 而对象引用存储在<strong>栈内存</strong>中。  </li><li>对象实体的生命周期由垃圾回收器管理。当没有任何引用指向该对象时，它会被垃圾回收器回收。   </li><li>对象引用的生命周期与栈中的方法调用相关，当方法调用结束时，栈中的局部变量（包括对象引用）会被销毁。  </li><li>一个对象引用可以指向0个或一个对象实体 ，一个对象实体可以有多个对象引用指向它。</li></ul><h3 id="对象的相等和引用相等的区别"><a href="#对象的相等和引用相等的区别" class="headerlink" title="对象的相等和引用相等的区别"></a>对象的相等和引用相等的区别</h3><ul><li>对象相等是指两个不同的对象是否具有相同的内容，也就是它们的属性值是否相等。  </li><li>引用相等是指两个对象引用是否指向同一个内存地址，也就是它们是否指向同一个对象实例。</li></ul><h3 id="构造方法有哪些特点？"><a href="#构造方法有哪些特点？" class="headerlink" title="构造方法有哪些特点？"></a>构造方法有哪些特点？</h3><ul><li>构造方法（Constructor）是类中的一种特殊方法，用于在创建对象时初始化对象的状态。</li><li>构造方法的名称必须与类名完全相同，且没有返回类型，不能使用void声明。</li><li>且构造方法可以被重载。因此，一个类中可以有多个构造方法，这些构造方法具有不同的参数列表，以提供不同的对象初始化方式。</li></ul><h3 id="构造方法是否可被-override"><a href="#构造方法是否可被-override" class="headerlink" title="构造方法是否可被 override?"></a>构造方法是否可被 override?</h3><ul><li>构造方法<strong>不能被重写（override）</strong>。</li><li><font style="background-color:rgb(253, 253, 254);">在Java中，子类可以继承父类的属性和方法。但是，由于构造方法不是类的成员，因此它们不会被子类继承，也就不存在被重写的问题。</font></li><li><font style="color:rgb(0, 0, 0);">另外方法重写(override)针对的方法签名是一样的，而父类和子类的构造器都必须以类名命，</font><font style="background-color:rgb(253, 253, 254);">因此不符合方法重写的定义。</font></li><li>当子类创建一个实例时，它总是首先调用父类的构造方法 ，如果子类重写了父类的构造方法， 可能会导致父类的初始化逻辑无法执行，从而破坏对象的完整性和一致性。</li></ul><h2 id="面向对象特性"><a href="#面向对象特性" class="headerlink" title="面向对象特性"></a>面向对象特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>概念</strong></p><p>封装是面向对象的基本特性之一，它指的是将对象的属性（数据）和行为（方法）绑定在一起，<font style="background-color:rgb(253, 253, 254);">并隐藏对象的内部细节，仅对外暴露必要的接口以进行访问和修改。</font></p><p><strong>实现方式</strong></p><p><font style="background-color:rgb(253, 253, 254);">通过访问控制修饰符（如 </font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;private&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);">、</font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;protected&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);">、</font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;public&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);">）来控制属性和方法的可见性。 常见的做法是将类的成员变量设为 </font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;private&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);">，而提供公共的 getter 和 setter 方法进行访问。  </font></p><p><strong><font style="background-color:rgb(253, 253, 254);">好处</font></strong></p><ul><li><strong><font style="background-color:rgb(253, 253, 254);">提高了安全性</font></strong><font style="background-color:rgb(253, 253, 254);">，防止外部代码直接访问和修改对象的内部状态。</font></li><li><strong><font style="background-color:rgb(253, 253, 254);">提高了灵活性</font></strong><font style="background-color:rgb(253, 253, 254);">，可以在不改变外部接口的情况下，修改对象的内部实现。</font></li></ul><p><font style="background-color:rgb(253, 253, 254);"></font></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><strong>概念</strong></p><p><font style="background-color:rgb(253, 253, 254);">继承是面向对象的另一个基本特性  ，它允许一个类继承另一个类的属性和方法。子类可以重用父类的代码，同时也可以添加或覆盖父类的方法，实现代码复用和扩展。</font></p><p><strong><font style="background-color:rgb(253, 253, 254);">实现</font></strong></p><p><font style="background-color:rgb(253, 253, 254);">在 Java 中，子类通过 </font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;extends&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);"> 关键字继承父类的属性和方法。子类可以继承父类的所有公共和保护成员（字段和方法），并且可以重写父类的方法来实现不同的行为。  </font></p><p><strong><font style="background-color:rgb(253, 253, 254);">好处</font></strong></p><ul><li><strong><font style="background-color:rgb(253, 253, 254);">提高代码复用性</font></strong><font style="background-color:rgb(253, 253, 254);">，通过继承，子类可以重用父类的代码，减少代码冗余。</font></li><li><strong><font style="background-color:rgb(253, 253, 254);">易于维护</font></strong><font style="background-color:rgb(253, 253, 254);">：当父类的代码需要修改时，只需要修改一个地方，所有继承该父类的子类都会自动更新。</font></li></ul><p><strong>注意!</strong></p><ol><li>子类拥有父类对象所有的属性和方法，但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>Java 是单继承的，即每个类只能有一个直接父类。</li></ol><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><strong>概念</strong></p><p>多态指的是在面向对象编程中， 同一个方法可以执行不同的行为。具体来说，多态允许通过父类引用指向子类对象，从而在运行时根据对象的实际类型来决定调用哪个方法。  </p><p><strong>实现</strong></p><p>多态可以通过编译时多态（静态多态）和运行时多态（动态多态）实现。</p><ol><li>编译时多态（静态多态）：<ul><li>主要通过<strong>方法重载（Method Overloading）</strong>来实现。</li><li>方法重载是指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可。</li><li>编译器在编译时就能够根据方法调用传入的参数类型来确定调用哪个方法。</li></ul></li><li>运行时多态（动态多态）：<ul><li>主要通过<strong>方法重写（Method Overriding）</strong>和<strong>接口实现</strong>来实现的。</li><li><font style="background-color:rgb(253, 253, 254);">当使用父类类型的引用来指向子类对象时，JVM会在运行时根据对象的实际类型来确定应该调用哪个方法。</font></li><li><font style="background-color:rgb(253, 253, 254);">当使用接口类型的引用来指向一个实现了该接口的对象时，同样JVM会在运行时根据对象的实际类型来确定应该调用哪个具体的实现。</font></li></ul></li></ol><p><strong>好处</strong></p><ul><li><strong><font style="background-color:rgb(253, 253, 254);">提高了代码的灵活性和可扩展性</font></strong><font style="background-color:rgb(253, 253, 254);">，当需要添加新的功能时，只需要添加新的类并实现相应的接口或继承相应的父类即可，而无需修改现有的代码。</font></li></ul><h3 id="接口和抽象类的共同点"><a href="#接口和抽象类的共同点" class="headerlink" title="接口和抽象类的共同点"></a>接口和抽象类的共同点</h3><ul><li><strong>实例化</strong>：接口和抽象类<strong>都不能直接实例化</strong>，只能被实现（接口）或被继承（抽象类）后才能创建具体的对象。</li><li><strong>抽象方法</strong>：接口和抽象类都可以包含抽象方法。抽象方法没有方法体，必须在子类或实现类中实现。</li><li><strong>具体方法</strong>: 从 Java 8 开始，接口可以有默认方法（<code>default</code> 方法），这些方法可以有具体实现，而抽象类始终可以有具体方法。</li></ul><h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ul><li><strong>设计目的</strong>：接口主要用于对类的行为进行约束，<font style="background-color:rgb(253, 253, 254);">而不关心这些行为的具体实现。 抽象类用于对一些共有特征或行为的抽象，其中为子类提供了共享的属性和方法。它是对类的抽象，提供了子类可以继承的公共行为。</font></li><li><strong>继承和实现</strong>：一个类可以实现多个接口，但只能继承一个抽象类。</li><li><strong>成员变量</strong>：接口中的成员变量默认是 <code>public static final</code> 类型的，不能被修改且必须有初始值。抽象类的成员变量可以有任何修饰符，可以在子类中被重新定义或赋值。</li><li><strong>方法</strong>：Java 8 之前，接口中的方法默认是 <code>public abstract</code> ，也就是只能有方法声明。自 Java 8 起，可以在接口中定义 <code>default</code>（默认） 方法和 <code>static</code> （静态）方法，可以<font style="background-color:rgb(253, 253, 254);">有具体实现</font><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">。</font> 自 Java 9 起，接口可以包含 <code>private</code> 方法。<font style="background-color:rgb(253, 253, 254);">而抽象类中的方法可以有具体的实现，也可以有抽象方法（没有具体实现的方法）。</font></li></ul><blockquote><p>Java 8 引入的<code>default</code> 方法用于提供接口方法的默认实现，可以在实现类中被覆盖。这样就可以在不修改实现类的情况下向现有接口添加新功能，从而增强接口的扩展性和向后兼容性。</p><p>Java 8 引入的<code>static</code> 方法无法在实现类中被覆盖，只能通过接口名直接调用（ <code>MyInterface.staticMethod()</code>），类似于类中的静态方法。<code>static</code> 方法通常用于定义一些通用的、与接口相关的工具方法，一般很少用。</p><p><font style="color:#3c3c43;">Java 9 允许在接口中使用</font> <code>private</code> <font style="color:#3c3c43;">方法。</font><code>private</code><font style="color:#3c3c43;">方法可以用于在接口内部共享代码，不对外暴露。</font></p></blockquote><h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝是指在复制对象时，在堆上创建一个新的对象，如果原对象包含基本数据类型字段，这些字段会被值拷贝；如果包含引用类型字段（如对象、数组等），这些字段会被引用拷贝，也就是说，<font style="color:rgb(77, 77, 77);">对于引用类型的成员，实际上复制的是引用，而不是引用所指向的对象。</font>即新对象和原对象的引用类型字段会指向同一个内存地址。</p><p><strong>特征</strong>：</p><ul><li>基本数据类型字段会被复制，即深度复制它们的值。</li><li>引用类型字段会复制引用，指向原始对象中的同一实例。</li></ul><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p><font style="color:rgb(77, 77, 77);">创建一个新对象，不仅复制基本数据类型成员的值，对于引用数据类型的成员及这些成员所引用的其他对象，都会递归地会为其创建新的对象，并复制其内容，使得新对象和原始对象完全独立，修改其中一个对象的引用类型成员不会影响到另一个对象。</font></p><p><strong>特征</strong><font style="background-color:rgb(253, 253, 254);">：</font></p><ul><li><font style="background-color:rgb(253, 253, 254);">基本数据类型字段会被复制。</font></li><li><font style="background-color:rgb(253, 253, 254);">引用类型字段会被递归复制，即每个引用类型字段都会新建一个对象。</font></li></ul><h3 id="引用拷贝"><a href="#引用拷贝" class="headerlink" title="引用拷贝"></a>引用拷贝</h3><p>将一个对象的引用直接赋值给另一个变量，这两个引用类型的变量指向同一个对象。这样在修改其中一个变量指向的对象时，另一个变量也会随之改变。实际上引用拷贝并不是真正意义上的拷贝，而是共享同一份数据。</p><p><strong>特征</strong><font style="background-color:rgb(253, 253, 254);">：引用拷贝并不会复制对象的内容，而是直接复制对象的内存地址。结果是，源对象和目标对象指向同一个对象，它们的内容会随着任意一个对象的变化而变化。  </font></p><h3 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="headerlink" title="深拷贝和浅拷贝的区别"></a><font style="color:rgb(79, 79, 79);">深拷贝和浅拷贝的区别</font></h3><ul><li><strong>浅拷贝</strong>复制对象时，<font style="background-color:rgb(253, 253, 254);">对于字段中的引用类型（如对象、数组等），只会复制其引用，而不会递归地创建新的对象。这意味着源对象和目标对象共享对引用类型字段的引用。</font></li><li><strong>深拷贝</strong><font style="background-color:rgb(253, 253, 254);">复制对象时，会为每个引用类型字段递归地创建一个新的对象，因此源对象和目标对象完全独立，修改一个对象不会影响另一个对象。</font></li></ul><p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/shallow&deep-copy.png"></p><h3 id="怎样实现浅拷贝和深拷贝"><a href="#怎样实现浅拷贝和深拷贝" class="headerlink" title="怎样实现浅拷贝和深拷贝"></a>怎样实现浅拷贝和深拷贝</h3><p><strong><font style="background-color:rgb(253, 253, 254);">浅拷贝实现</font></strong></p><p><font style="background-color:rgb(253, 253, 254);">在Java中，要实现浅拷贝，可以让类实现</font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;Cloneable&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);">接口，并重写</font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;clone()&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);">方法。</font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;Object&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);">类中的</font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;clone()&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);">方法是受保护的，因此需要在子类中暴露它（通常是通过</font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;public&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);">方法）。浅拷贝的实现相对简单，因为它只需要调用超类的</font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;clone()&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);">方法（即</font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;super.clone()&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);">），这会复制当前对象并返回一个新的实例，但只复制基本数据类型和引用类型的引用，而不复制引用的对象本身。</font></p><p><strong><font style="background-color:rgb(253, 253, 254);">深拷贝实现</font></strong></p><p><font style="background-color:rgb(253, 253, 254);">要实现深拷贝，除了让类实现</font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;Cloneable&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);">接口并重写</font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;clone()&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);">方法外，还需要在</font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;clone()&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);">方法内部对所有的引用类型属性进行递归的克隆。这意味着每个引用类型属性所指向的对象也必须实现</font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;Cloneable&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);">接口，并且有自己的</font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;clone()&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);">方法实现。在重写</font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;clone()&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);">方法时，需要手动调用这些引用类型属性的</font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;clone()&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);">方法，以确保它们也被深拷贝。</font></p><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="Object-类的常见方法有哪些？"><a href="#Object-类的常见方法有哪些？" class="headerlink" title="Object 类的常见方法有哪些？"></a>Object 类的常见方法有哪些？</h3><p>Object 类是一个特殊的类，是所有类的父类，主要提供了以下 11 个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass()<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实例被垃圾回收器回收的时候触发的操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; &#125;<br></code></pre></td></tr></table></figure><h3 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="&#x3D;&#x3D; 和 equals() 的区别"></a>&#x3D;&#x3D; 和 equals() 的区别</h3><p><code>==</code>是操作符</p><ul><li>对于基本数据类型来说，<code>==</code> 比较的是值。</li><li>对于引用数据类型来说，<code>==</code><font style="background-color:rgb(253, 253, 254);"> 比较的是两个引用是否指向同一个对象（即它们所储存的内存地址是否相同）。</font></li></ul><p><code>equals()</code> 是 <code>Object</code> 类的方法，所有类都继承了这个方法。它用于比较两个对象是否相同。具体的实现依赖于类是否重写了 <code>equals()</code> 方法。  </p><p>如果类没有重写 <code>equals()</code> 方法，它会继承 <code>Object</code> 类中的<code>equals()</code>方法。默认情况下，等价于通过“&#x3D;&#x3D;”比较这两个对象。</p><p>如果类重写了 <code>equals()</code>方法，可以比较两个对象中的内容是否相等；若它们的内容相等，则返回 true。</p><h3 id="hashCode的作用"><a href="#hashCode的作用" class="headerlink" title="hashCode的作用"></a>hashCode的作用</h3><p><code>**hashCode()**</code> 返回一个整数，用来表示对象的<strong>哈希值</strong>。</p><p><strong>hashCode可以优化查找效率</strong>，集合类（如 <code>HashMap</code>、<code>HashSet</code>）通常通过哈希表（<code>hash table</code>）来存储元素。哈希表使用 <strong>哈希值</strong> 来决定对象存储的位置，从而可以在常数时间内（O(1)）找到对象。</p><p>且通过 <code>hashCode()</code>，集合类可以首先使用哈希值进行初步的快速查找。如果两个对象的哈希值不同，集合类就可以立即确定它们不相等，从而避免了调用 <code>equals()</code> 进行更昂贵的比较。</p><h3 id="两个对象的-hashCode-相同，则-equals-是否也一定为-true吗？"><a href="#两个对象的-hashCode-相同，则-equals-是否也一定为-true吗？" class="headerlink" title="两个对象的 hashCode()相同，则 equals()是否也一定为 true吗？"></a>两个对象的 hashCode()相同，则 equals()是否也一定为 true吗？</h3><p>两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等，因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关。</p><h3 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h3><p><font style="background-color:rgb(253, 253, 254);">如果重写了</font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;equals()&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);">方法但没有重写</font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;hashCode()&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);">方法，就可能导致两个内容相等的对象（即</font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;equals()&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);">方法返回</font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;true&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);">）可能会有不同的</font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;hashCode()&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);">值。</font></p><p><font style="background-color:rgb(253, 253, 254);">这会使得在使用基于哈希的集合时，这些对象被视为不同的元素，从而导致集合中出现重复元素的问题。</font></p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String、StringBuffer、StringBuilder-的区别？"><a href="#String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？"></a>String、StringBuffer、StringBuilder 的区别？</h3><p><strong>可变性</strong></p><ul><li>String是不可变的，一旦创建后其内容无法更改。每次修改 String 时，都会创建一个新的对象。</li><li><code>StringBuilder</code>与<code>StringBuffer</code>都继承自<code>AbstractStringBuilder</code>类，<code>AbstractStringBuilder</code>定义了一些字符串的基本操作，如append、insert 等方法，因此StringBuffer和StringBuilder <font style="background-color:rgb(253, 253, 254);">允许对字符串进行修改而不会创建新的对象。</font></li></ul><p><strong>线程安全性</strong></p><ul><li><font style="background-color:rgb(253, 253, 254);">由于String是不可变的，因此它是线程安全的。多个线程可以安全地共享同一个String对象。</font></li><li><font style="background-color:rgb(253, 253, 254);">StringBuffer也是线程安全的，因为它的所有方法都被</font><code>synchronized</code><font style="background-color:rgb(253, 253, 254);">关键字修饰。</font></li><li><font style="background-color:rgb(253, 253, 254);">而StringBuilder不是线程安全的，它的方法没有被</font><code>synchronized</code><font style="background-color:rgb(253, 253, 254);">修饰，因此在多线程环境中使用可能会导致数据不一致的问题。</font></li></ul><p><strong>性能</strong></p><ul><li><strong><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">Str</font>****<font style="background-color:rgb(253, 253, 254);">ing</font></strong><font style="background-color:rgb(253, 253, 254);">：由于String的不可变性，每次对String的修改都会创建新的对象，这会导致大量的内存分配和垃圾回收，从而影响性能。</font></li><li><strong><font style="background-color:rgb(253, 253, 254);">StringBuffer</font></strong><font style="background-color:rgb(253, 253, 254);">：由于StringBuffer是线程安全的，它的性能在多线程环境中是可靠的，但在单线程环境中，由于</font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;synchronized&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);">关键字的开销，它的性能可能略低于StringBuilder。</font></li><li><strong><font style="background-color:rgb(253, 253, 254);">StringBuilder</font></strong><font style="background-color:rgb(253, 253, 254);">：StringBuilder在单线程环境中提供了更高的性能。由于没有线程安全的开销，它可以更快地执行字符串修改操作。</font></li></ul><p><strong>总结：</strong></p><ul><li><code>String</code>：不可变，线程安全，适合常量和少量修改。</li><li><code>StringBuffer</code>：可变，线程安全，适合多线程修改。</li><li><code>StringBuilder</code>：可变，非线程安全，适合单线程修改。</li></ul><h3 id="String-为什么是不可变的"><a href="#String-为什么是不可变的" class="headerlink" title="String 为什么是不可变的?"></a>String 为什么是不可变的?</h3><ul><li>String类被final修饰，意味着String不能被继承，防止子类重写其方法。 </li><li>String 中存储字符串数据的字段 value是一个字符数组 <strong>，</strong>被声明为 final 和 private，意味着value数组在初始化后不能被修改指向其他数组。</li><li>且String类没有提供任何可以修改自身内容的方法  </li><li>String 不可变的设计使得 Java 可以在字符串常量池中安全地共享和复用字符串，提高内存使用效率。  </li><li><font style="background-color:rgb(253, 253, 254);">多个线程可以安全地共享一个 </font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;String&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);"> 实例，因为它的值不能被改变。这减少了同步的开销，避免了多线程环境下的数据竞争和不一致性。  </font></li></ul><h3 id="字符串拼接用“-”-还是-StringBuilder"><a href="#字符串拼接用“-”-还是-StringBuilder" class="headerlink" title="字符串拼接用“+” 还是 StringBuilder?"></a>字符串拼接用“+” 还是 StringBuilder?</h3><p>字符串对象通过+拼接，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p><p>对于少量的字符串拼接，用<code>+</code> 更为简洁和易读。  </p><p><font style="background-color:rgb(253, 253, 254);">但对于大量的字符串拼接操作，尤其是在循环中，直接使用 </font><code>+</code><font style="background-color:rgb(253, 253, 254);"> 运算符可能会导致性能问题，因为它每次都会创建一个新的 </font><code>String</code><font style="background-color:rgb(253, 253, 254);"> 对象。这会增加内存消耗 。</font></p><p>而StringBuilder 是一个可变的字符序列，它提供了用于字符串拼接的 append 方法。与 String 不同，StringBuilder 不会每次拼接都创建新的对象，而是在内部维护一个可变的字符数组，并随着拼接操作的进行而动态地调整其大小。</p><p>因此，当需要执行大量的字符串拼接操作时，使用 StringBuilder 通常会比使用 + 运算符更高效，因为它避免了频繁的对象创建和内存分配。</p><h3 id="字符串常量池了解吗？"><a href="#字符串常量池了解吗？" class="headerlink" title="字符串常量池了解吗？"></a>字符串常量池了解吗？</h3><p><strong>概念</strong></p><p>字符串常量池是一个存储字符串字面量的特殊内存区域。相同内容的字符串只会在池中存储一份，从而节省内存并提高性能。  </p><p><strong>作用</strong></p><p><font style="background-color:rgb(253, 253, 254);">当你在代码中创建一个常量字符串时，JVM 首先会先检查该字符串是否已经存在于常量池中。如果存在，就直接返回池中的引用，而不是重新创建一个新的 </font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;String&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);"> 对象。 这样可以使得多个相同内容的字符串共享同一个实例，避免了重复的对象创建，从而减少了内存分配和垃圾回收的压力。  </font></p><h3 id="字符串对象的创建过程"><a href="#字符串对象的创建过程" class="headerlink" title="字符串对象的创建过程"></a><font style="background-color:rgb(253, 253, 254);">字符串对象的创建过程</font></h3><p><strong>字面量字符串</strong>：当你在 Java 代码中使用字符串字面量（如 <code>&quot;hello&quot;</code>）时，<font style="background-color:rgb(253, 253, 254);">JVM会首先在字符串常量池中查找是否存在字面量”hello”。如果存在，则直接返回该字面量对应的字符串对象的引用；如果不存在，则创建一个新的字符串对象并将其添加到字符串常量池中，然后返回该对象的引用。</font></p><p><strong>通过 <strong><code>**new**</code></strong> 创建字符串</strong>：当你使用 <code>new String(&quot;hello&quot;)</code> 创建一个字符串时，<font style="background-color:rgb(253, 253, 254);">无论字符串常量池中是否已经存在字面量”hello”，JVM都会在堆内存中创建一个新的字符串对象。然后，它会检查字符串常量池中是否存在该字面量，并将新创建的字符串对象的内部字段（如字符数组引用）设置为指向常量池中该字面量对应的字符串对象的内部字段。但新创建的字符串对象和常量池中的字符串对象是两个不同的对象，它们只是内部字段引用指向了相同的字符数组。</font></p><h3 id="String-s1-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#String-s1-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？"></a>String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</h3><p>会创建 1 或 2 个字符串对象。</p><p>如果字符串常量池中不存在 “abc”，则会<font style="background-color:rgb(253, 253, 254);">创建一个新的字符串对象并放入池中。</font></p><p><font style="background-color:rgb(253, 253, 254);">且不管常量池中是否存在</font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;&quot;abc&quot;&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);">字面量，</font><code>&lt;font style=&quot;background-color:rgb(253, 253, 254);&quot;&gt;new&lt;/font&gt;</code><font style="background-color:rgb(253, 253, 254);">关键字仍然会在堆上创建一个新的字符串对象。</font></p><h3 id="String-s1-“abc”-String-s2-new-String-“abc”-的区别"><a href="#String-s1-“abc”-String-s2-new-String-“abc”-的区别" class="headerlink" title="String s1 &#x3D; “abc”  String s2 &#x3D; new String(“abc”) 的区别"></a>String<font style="color:#383a42;"> </font>s1<font style="color:#383a42;"> </font>&#x3D;<font style="color:#383a42;"> </font>“abc”  String<font style="color:#383a42;"> </font>s2<font style="color:#383a42;"> </font>&#x3D;<font style="color:#383a42;"> </font>new<font style="color:#383a42;"> </font>String(“abc”)<font style="color:#383a42;"> </font>的区别</h3><p>String s1 &#x3D; “abc” ， 如果常量池中没有该字符串的话 ，会在字符串常量池中创建一个字符串对象 “abc”，然后将s1指向这个字符串对象， 如果常量池中已经存在 <code>&quot;abc&quot;</code>，则 <code>s1</code> 将指向常量池中已有的 <code>&quot;abc&quot;</code> 对象。  </p><p>String s2 &#x3D; new String(“abc”); 这行代码会在堆内存中创建一个新的字符串对象”abc”，然后s2指向这个字符串对象。</p><h3 id="String-intern-方法有什么作用"><a href="#String-intern-方法有什么作用" class="headerlink" title="String#intern 方法有什么作用?"></a>String#intern 方法有什么作用?</h3><p><code>intern()</code> 会检查常量池中是否已经存在一个与当前字符串内容相同的字符串。如果存在，则返回池中该字符串的引用；如果不存在，则将该字符串添加到常量池中，并返回该字符串的引用。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String a=<span class="hljs-string">&quot;abc&quot;</span>;<br>String b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br>System.out.println(a==b);  <span class="hljs-comment">//false</span><br>System.out.println(a==b.intern());  <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java后端面经</category>
      
      <category>java后端-八股</category>
      
      <category>java-面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java后端面经</tag>
      
      <tag>八股</tag>
      
      <tag>java-面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring-bean</title>
    <link href="/2024/11/21/bean/"/>
    <url>/2024/11/21/bean/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol><li><strong>基本概念</strong>：Bean是由Spring IoC容器实例化、组装和管理的一个对象，它是Spring应用程序的基本构建块。</li><li><strong>管理范围</strong>：Bean可以是Java对象、组件、服务，或者是应用程序中的任何一个被Spring容器管理的对象。</li></ol><h3 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a><strong>名词介绍</strong></h3><ul><li>实例化：Spring 容器负责实例化 Bean。当应用程序启动时，Spring 容器会根据配置信息或注解扫描的结果，找到并实例化所有被标记为 Bean 的类，并将它们加入容器中。实例化的过程由 Spring 的 IoC 容器负责。</li><li>管理：一旦 Bean 被实例化，Spring 容器将负责管理 Bean 的生命周期和依赖关系。它会根据配置文件或注解的信息，自动解决 Bean 之间的依赖关系，确保在需要的时候正确的注入依赖。Spring 容器还会负责销毁不再需要的 Bean。</li><li>依赖注入：依赖注入是 Spring 框架的一个重要特性，它允许通过自动或显式配置的方式将 Bean 的依赖项注入到其它 Bean 中。依赖注入可以通过构造函数注入、Setter 方法注入或字段注入的方式实现，其中最常见的是使用 ‘@Autowired’注解进行注入。</li><li>作用域：Spring 框架提供了多种作用域（scope）来管理 Bean 的生命周期。常见的作用域包括单例（Singleton）、原型（Prototype）、会话（Session）、请求（Request）等。默认情况下，Bean 是单例的，即每个容器中只存在一个实例。但可以根据需要配置其它作用域。</li><li>自动装配：Spring Boot 支持自动装配（Auto - wiring），它能够根据类型或名称自动解析和注入依赖关系。通过在需要注入的字段、构造函数或 Setter 方法上使用 ‘@Autowired’ 注解，Spring 容器会自动查找并注入对应的 Bean。</li></ul><p>总的来说，Bean 是 Spring 框架中被实例化、管理和维护的对象。通过在类上使用 ‘@Component’ 注解或其派生注解，将一个类声明为 Bean，并将其交给 Spring 容器处理。Spring 容器负责实例化、管理和维护 Bean 的生命周期和依赖关系。通过依赖注入和自动装配，应用程序可以方便的使用和管理 Bean。</p><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><font style="color:#05073b;">自动装配是指Spring框架通过一定的规则，在容器中自动为Bean之间建立依赖关系的过程。在使用自动装配时，开发者无需显式地指定Bean之间的依赖关系，Spring会根据一些配置信息自动将合适的Bean注入到目标Bean中。</font></p><h3 id="Spring-Boot-自动装配的实现"><a href="#Spring-Boot-自动装配的实现" class="headerlink" title="Spring Boot 自动装配的实现"></a>Spring Boot 自动装配的实现</h3><h3 id="核心注解与自动配置机制"><a href="#核心注解与自动配置机制" class="headerlink" title="核心注解与自动配置机制"></a>核心注解与自动配置机制</h3><ol><li><strong>@SpringBootApplication注解</strong>：<ul><li>这是一个组合注解，包含了@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan三个重要注解。</li><li>@SpringBootConfiguration：表明这是一个Spring Boot的配置类。</li><li>@EnableAutoConfiguration：启用Spring Boot的自动配置机制。</li><li>@ComponentScan：启用组件扫描，以便找到带有@Component、@Service、@Repository、@Controller等注解的Spring组件，并将它们注册为Spring Bean。</li></ul></li><li><strong>@EnableAutoConfiguration注解</strong>：<ul><li>触发自动配置机制。</li><li>Spring Boot会根据类路径中的依赖、属性文件中的配置以及其他环境变量来判断并自动配置应用所需的Bean。</li></ul></li></ol><h3 id="二、spring-factories文件与自动配置类"><a href="#二、spring-factories文件与自动配置类" class="headerlink" title="二、spring.factories文件与自动配置类"></a>二、spring.factories文件与自动配置类</h3><ol><li><strong>spring.factories文件</strong>：<ul><li>位于META-INF目录下。</li><li>列出了所有的自动配置类（Auto-Configuration Classes）。</li><li>在Spring应用上下文初始化时，这些自动配置类会被加载，并根据条件自动配置相应的Bean。</li></ul></li><li><strong>自动配置类</strong>：<ul><li>自动配置类通常使用条件注解（Conditional Annotations）来控制Bean的装配。</li><li>常见的条件注解包括：<ul><li>@ConditionalOnClass：只有在指定的类在类路径上存在时才会装配Bean。</li><li>@ConditionalOnMissingBean：只有在指定的Bean不存在时才会装配Bean。</li><li>@ConditionalOnProperty：只有在指定的属性存在并具有特定值时才会装配Bean。</li></ul></li></ul></li></ol><h3 id="三、组件扫描与Bean注册"><a href="#三、组件扫描与Bean注册" class="headerlink" title="三、组件扫描与Bean注册"></a>三、组件扫描与Bean注册</h3><ol><li><strong>组件扫描</strong>：<ul><li>通过@ComponentScan注解启用组件扫描。</li><li>Spring会扫描指定包及其子包中的所有组件（带有@Component、@Service、@Repository、@Controller等注解的类），并将它们注册为Spring Bean。</li></ul></li><li><strong>Bean注册</strong>：<ul><li>在自动配置过程中，Spring Boot会根据检测到的依赖和条件注解来判断是否需要创建和注册Bean。</li><li>如果满足条件，Spring Boot会创建对应的Bean，并将其注册到Spring应用程序上下文中，以供应用程序使用。</li></ul></li></ol><h3 id="四、自定义自动配置"><a href="#四、自定义自动配置" class="headerlink" title="四、自定义自动配置"></a>四、自定义自动配置</h3><p>除了使用Spring Boot提供的自动配置外，开发者还可以自定义自己的自动配置：</p><ol><li>创建一个配置类，并在类上添加@Configuration和@EnableConfigurationProperties注解。</li><li>在配置类中使用条件注解（如@ConditionalOnClass、@ConditionalOnMissingBean等）指定自动配置的条件。</li><li>使用@ConfigurationProperties注解创建配置属性类，并在配置类中注入该属性类。</li><li>编写需要自动配置的Bean，并使用@Bean注解将Bean注册到容器中。</li></ol><p>综上所述，Spring Boot通过核心注解、spring.factories文件、自动配置类、组件扫描与Bean注册以及自定义自动配置等机制和步骤实现了bean的自动装配。这使得开发者可以更加便捷地集成第三方组件和库，并在应用程序中使用它们，而无需手动配置大量的XML文件或Java配置类。</p><h2 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h2><p>注入是指将依赖对象（Bean）的引用或数值注入到目标对象（Bean）中的过程。Spring支持多种注入方式，包括构造器注入、Setter方法注入和字段注入。</p><ol><li><strong>构造器注入（Constructor Injection）</strong>：<ul><li>通过构造方法将依赖对象注入到目标对象中。</li><li>实现方式：在目标对象的构造方法中声明参数，Spring容器负责将依赖对象的实例传递给构造方法。</li><li>优点：确保依赖对象在目标对象创建时即被注入，避免了后续注入可能带来的不确定性。</li></ul></li><li><strong>Setter方法注入（Setter Injection）</strong>：<ul><li>通过Setter方法将依赖对象注入到目标对象中。</li><li>实现方式：在目标对象中提供一个Setter方法，Spring容器负责调用该方法并传递依赖对象的实例。</li><li>优点：灵活性高，可以在目标对象创建后再进行依赖注入。</li></ul></li><li><strong>字段注入（Field Injection）</strong>：<ul><li>通过字段直接将依赖对象注入到目标对象中。</li><li>实现方式：在目标对象中声明一个字段，并使用<code>@Autowired</code>、<code>@Inject</code>等注解标记该字段，Spring容器负责将依赖对象的实例注入该字段。</li><li>优点：简洁明了，减少了代码量。但可能导致测试困难，因为依赖对象在字段声明时即被注入，不易于替换为模拟对象。</li></ul></li></ol><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p> <font style="color:#05073b;">Spring Bean的生命周期是指从Bean的创建到销毁所经历的一系列过程。这个过程由Spring容器进行管理，确保了Bean的实例化和依赖注入等操作的正确执行。</font></p><h3 id="Bean定义"><a href="#Bean定义" class="headerlink" title="Bean定义"></a>Bean定义</h3><ul><li>在Spring配置文件中或通过注解等方式定义Bean，包括Bean的类名、作用域、依赖关系等。</li><li>Spring容器在启动时扫描这些配置，并解析成内部的BeanDefinition对象，<font style="color:#05073b;">该对象包含了Bean的各种定义信息。</font></li></ul><h3 id="Bean实例化"><a href="#Bean实例化" class="headerlink" title="Bean实例化"></a><font style="color:#05073b;">Bean实例化</font></h3><ul><li>对于BeanFactory容器，当用户请求一个尚未初始化的Bean时，容器会调用createBean方法进行实例化。</li><li>对于ApplicationContext容器，在容器启动时就会实例化所有非延迟加载的Bean。</li><li>实例化过程仅仅是创建Bean的实例，并未进行依赖注入和初始化。</li></ul><h3 id="Bean属性赋值"><a href="#Bean属性赋值" class="headerlink" title="Bean属性赋值"></a>Bean属性赋值</h3><ul><li>Spring根据BeanDefinition中的信息，通过反射机制为Bean的属性赋值。</li><li>例如<code>@Autowired</code> 等注解注入的对象、<code>@Value</code> 注入的值、<code>setter</code>方法或构造函数注入依赖和值、<code>@Resource</code>注入的各种资源。</li></ul><h3 id="Bean初始化"><a href="#Bean初始化" class="headerlink" title="Bean初始化"></a>Bean初始化</h3><ol><li><strong>Aware接口回调</strong>：<ul><li>如果Bean实现了xxxAware接口（如BeanNameAware、BeanFactoryAware等），Spring容器会在Bean初始化前后调用相应的set方法，将相关的Aware实例注入给Bean。</li></ul></li><li><strong>BeanPostProcessor前置处理</strong>：<ul><li>在Bean初始化之前，Spring容器会调用实现了BeanPostProcessor接口的类的postProcessBeforeInitialization方法，对Bean进行前置处理。</li></ul></li><li><strong>初始化Bean</strong>：<ul><li>如果Bean实现了InitializingBean接口，Spring容器会调用其afterPropertiesSet方法进行初始化。</li><li>或者，如果Bean在配置中指定了init-method属性，Spring容器会调用该属性指定的方法进行初始化。</li></ul></li><li><strong>BeanPostProcessor后置处理</strong>：<ul><li>在Bean初始化之后，Spring容器会调用实现了BeanPostProcessor接口的类的postProcessAfterInitialization方法，对Bean进行后置处理。</li></ul></li></ol><h3 id="Bean销毁"><a href="#Bean销毁" class="headerlink" title="Bean销毁"></a>Bean销毁</h3><ul><li>对于单例作用域的Bean，Spring容器会负责其整个生命周期的管理。</li><li>当容器关闭时，如果Bean实现了DisposableBean接口，Spring容器会调用其destroy方法进行销毁。</li><li>或者，如果Bean在配置中指定了destroy-method属性，Spring容器会调用该属性指定的方法进行销毁。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/44994284/1729840510674-b48de1a2-b5eb-4b5a-8b0f-9357276e8091.png"></p>]]></content>
    
    
    <categories>
      
      <category>java后端面经</category>
      
      <category>java后端-八股</category>
      
      <category>Spring-面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java后端面经</tag>
      
      <tag>八股</tag>
      
      <tag>Spring-面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基础一</title>
    <link href="/2024/11/21/java-%E5%9F%BA%E7%A1%80%E4%B8%80/"/>
    <url>/2024/11/21/java-%E5%9F%BA%E7%A1%80%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h2><p>标识符是用来表示变量、函数、类等命名实体的名称。它由一系列字符组成，可以包含字母、数字和下划线，并且必须以字母或下划线开头。</p><p>关键字是具有特殊意义的单词。这些单词被保留，不能用作标识符来命名变量、函数或类等。</p><h3 id="java关键字有哪些"><a href="#java关键字有哪些" class="headerlink" title="java关键字有哪些"></a>java关键字有哪些</h3><p>有访问修饰符关键字，如public,private等</p><p>有定义类、接口的关键字，如class，interface</p><p>还有用于控制程序流程和用于声明不同的数据类型的关键字</p><p>还有用于修饰类、方法、属性和变量的关键字等如final，static等</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="java的几种基本数据类型了解吗"><a href="#java的几种基本数据类型了解吗" class="headerlink" title="java的几种基本数据类型了解吗"></a>java的几种基本数据类型了解吗</h3><p>Java 中有 8 种基本数据类型，分别为：</p><ul><li>6 种数字类型：<ul><li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>2 种浮点型：<code>float</code>、<code>double</code></li></ul></li><li>1 种字符类型：<code>char</code></li><li>1 种布尔型：<code>boolean</code>。</li></ul><h3 id="基本类型和包装类型的区别"><a href="#基本类型和包装类型的区别" class="headerlink" title="基本类型和包装类型的区别"></a>基本类型和包装类型的区别</h3><p>基本类型是 Java 中的八种原始数据类型，它们直接存储数据的值， 而包装类型是基本类型的<strong>对象。</strong></p><ul><li>**基本类型的局部变量 存放在 栈 中，直接存储数据值。而未被static修饰的基本类型的成员变量 存放在 堆 中，作为对象的一部分。包装类型是对象，存放在 堆 中， 并且包装类型在使用时会涉及到对象的创建和销毁。  **</li><li>包装类型适合需要对象的场景，比如集合类、反射等；基本类型适合更高效的运算和数据存储。  并且，<strong>包装类型可用于泛型，而基本类型不可以</strong>。</li><li><strong>默认值</strong>：包装类型不赋值就默认为 <code>null</code> ，而基本类型有默认值且不可以是 <code>null</code>。</li><li><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code>** 比较的是值<strong>。对于包装数据类型来说，<code>==</code></strong> 比较的是对象的内存地址**。</li></ul><h3 id="为什么说是几乎所有对象实例都存在于堆中呢？-还有对象存于栈中"><a href="#为什么说是几乎所有对象实例都存在于堆中呢？-还有对象存于栈中" class="headerlink" title="为什么说是几乎所有对象实例都存在于堆中呢？(&#x3D;&gt; 还有对象存于栈中)"></a>为什么说是几乎所有对象实例都存在于堆中呢？(&#x3D;&gt; 还有对象存于栈中)</h3><p>这是因为 HotSpot 虚拟机引入了 JIT(<font style="color:#05073b;">即时编译</font>) 优化之后，会对对象进行逃逸分析，<font style="background-color:#f3bb2f;">（</font><font style="color:#05073b;background-color:#f3bb2f;">确定一个对象是否会在其被分配的方法之外被引用（即“逃逸”），即</font><font style="color:#05073b;background-color:#f3bb2f;">帮助JVM确定一个对象的作用域是否仅限于当前线程和方法调用</font><font style="background-color:#f3bb2f;">）</font>，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换<font style="background-color:#f3bb2f;">（</font><font style="color:#05073b;background-color:#f3bb2f;">当</font><font style="color:#05073b;background-color:#f3bb2f;">逃逸分析确定一个对象不</font><font style="color:#05073b;background-color:#f3bb2f;">会逃逸时，JVM可能会将这个对象分解成一组标量字段，并将这些字段直接在栈上分配，而不是作为一个整体对象在堆上分配。</font><font style="background-color:#f3bb2f;">）</font>来实现栈上分配，而避免堆上分配内存</p><blockquote><p>⚠️ 注意：<strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的存储位置取决于它们的<strong>作用域和声明方式</strong>。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆&#x2F;方法区&#x2F;元空间中。</p></blockquote><h3 id="包装类型的缓存机制了解吗"><a href="#包装类型的缓存机制了解吗" class="headerlink" title="包装类型的缓存机制了解吗"></a>包装类型的缓存机制了解吗</h3><p>包装类型的缓存机制是指Java虚拟机为了优化性能和节省内存，会对一定范围内的包装类型对象进行缓存。当需要这些数值的包装类型对象时，JVM会直接从缓存池中返回已经存在的对象，而不是每次都创建一个新的对象。</p><p>比如<code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类通常缓存了从-128到127之间的数值。，<code>Character</code> 缓存了 <code>[0, 127]</code> 范围的字符  <code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>， 而 <code>Float</code> 和 <code>Double</code> 没有缓存机制，因为它们的数值范围大，缓存效果不明显。  </p><h3 id="自动装箱与拆箱了解吗？原理是什么？"><a href="#自动装箱与拆箱了解吗？原理是什么？" class="headerlink" title="自动装箱与拆箱了解吗？原理是什么？"></a>自动装箱与拆箱了解吗？原理是什么？</h3><p>自动装箱是 Java 自动将基本类型转换为包装类对象的过程；拆箱是将包装类对象转换为基本类型。</p><p><font style="color:#3c3c43;">装箱其实就是调用了 包装类的</font><code>valueOf()</code><font style="color:#3c3c43;">方法，比如 Integer.valueOf()  。拆箱其实就是调用了 </font><code>&lt;font style=&quot;color:#3c3c43;&quot;&gt;xxxValue()&lt;/font&gt;</code><font style="color:#3c3c43;">方法，比如 intValue()  。</font></p><p><font style="color:#3c3c43;"></font></p><h3 id="为什么浮点数运算的时候会有精度丢失的风险？"><a href="#为什么浮点数运算的时候会有精度丢失的风险？" class="headerlink" title="为什么浮点数运算的时候会有精度丢失的风险？"></a>为什么浮点数运算的时候会有精度丢失的风险？</h3><p> 计算机中的浮点数是使用二进制表示的， 无法精确表示所有的小数  ，这就导致了计算时的误差。例如，<code>0.1</code> 在二进制中是一个无限循环的小数，计算机会以有限的位数存储它，从而被截断，产生了微小的误差。而且在浮点数运算过程中，某些结果需要进行舍入。也会导致精度丢失的风险。</p><h3 id="如何解决浮点数运算的精度丢失问题？"><a href="#如何解决浮点数运算的精度丢失问题？" class="headerlink" title="如何解决浮点数运算的精度丢失问题？"></a>如何解决浮点数运算的精度丢失问题？</h3><p>可以使用BigDecimal 类进行浮点数的运算，BigDecimal 提供了任意精度的浮点数运算，可以避免浮点数的精度丢失问题。</p><p>还可以通过将所有的浮点数转换为整数来避免精度丢失。通常做法是将小数转化为<strong>整数</strong>，然后进行运算，最后再转换回小数。  </p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h3><ul><li><strong>语法形式</strong>：从语法形式上看，<strong>成员变量是属于类的</strong>，而<strong>局部变量是在代码块或方法中定义的变量或是方法的参数</strong>；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</li><li><strong>存储方式</strong>：从变量的存储方式来看， 成员变量中的静态变量，存储在堆内存中<strong>，</strong>实例变量存储于方法区中，而<strong>局部变量则存在于栈内存</strong>。</li><li><strong>生存时间</strong>：从变量的生命周期来看， 成员变量随着对象的创建而分配内存，随着对象的销毁而释放内存。  而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li><li><strong>默认值</strong>：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量必须在使用前初始化，JVM 不会为局部变量分配默认值。</li></ul><h3 id="为什么成员变量有默认值？"><a href="#为什么成员变量有默认值？" class="headerlink" title="为什么成员变量有默认值？"></a>为什么成员变量有默认值？</h3><ol><li>默认值避免了未初始化的成员变量存储随机值，从而确保程序运行时的稳定性。  </li><li>对于<strong>成员变量</strong>，它们的初始化可能是在运行时进行的（例如通过构造函数或其他方法），编译器无法在编译时判断是否被初始化。因此，如果不自动赋予默认值，编译器就无法判断这些成员变量是否已被初始化，这可能会导致错误或者不一致的行为。为了避免这种问题，JVM 采用了<strong>自动赋予默认值</strong>的策略。</li></ol><h3 id="静态变量有什么作用？"><a href="#静态变量有什么作用？" class="headerlink" title="静态变量有什么作用？"></a>静态变量有什么作用？</h3><ul><li>静态变量也就是被 <code>static</code> 关键字修饰的变量。 它属于类而不是类的实例。静态变量在类加载时初始化，并且在类的所有实例中共享。 也就是说，不管创建多少个类的实例，静态变量只有一份存储空间。  </li><li>静态变量不依赖于类的实例化，它属于类本身。可以直接通过类名来访问静态变量，而不需要创建类的实例。</li></ul><h3 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别?"></a>字符型常量和字符串常量的区别?</h3><ul><li><strong>形式</strong> : 字符型常量是一个单一的字符，使用单引号 (<code>&#39;</code>) 包裹 。字符串常量是一个字符的序列，使用双引号 (<code>&quot;</code>) 包裹。</li><li><strong>存储方式不同</strong> : 字符型常量在内存中作为 <code>char</code> 类型存储，每个字符占用 2 个字节。字符串常量的数据类型是 <code>String</code> ，它是一个对象类型  ，实际上是一个字符数组， 可以用来表示多个字符。</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员?"></a>静态方法为什么不能调用非静态成员?</h3><p><strong>静态方法</strong>是属于类的，而不是类的实例。在类加载时就可以被调用，无需创建对象。</p><p><strong>非静态成员</strong>是属于对象的。它们在类的实例化时才会被分配内存，意味着非静态成员是属于某个对象实例的。</p><p>当类的静态方法被调用时，对象实例还没有被创建。因此，静态方法调用时，并不能直接访问与某个实例相关的非静态成员，如实例变量和实例方法。 </p><h3 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h3><ul><li><strong>静态方法</strong>属于<strong>类</strong>本身，而不是类的实例。 可以通过类名直接调用，不需要创建类的实例。  </li><li><strong>实例方法</strong>属于<strong>对象实例</strong>，必须在创建对象之后才能使用，且需要通过类的实例来调用，</li><li>静态方法只允许访问静态成员，不允许访问实例成员，而实例方法不存在这个限制。</li><li><strong>静态方法</strong>的生命周期与类的生命周期相关，它在类加载时加载，直到类卸载时销毁。</li><li><strong>实例方法</strong>的生命周期与对象的生命周期相关，只有当对象被创建时，实例方法才会存在，并在对象销毁时随之销毁。</li></ul><h3 id="重载和重写有什么区别？"><a href="#重载和重写有什么区别？" class="headerlink" title="重载和重写有什么区别？"></a>重载和重写有什么区别？</h3><ul><li><strong>重载（Overloading）</strong>指的是在同一个类中，或者父类和子类之间，<strong>方法名相同</strong>，但<strong>参数列表不同</strong>的方法。这是编译时多态的一种体现。  </li><li><strong>重写（Overriding）</strong>指的是在子类中重新定义父类的方法，<strong>方法名、参数列表必须完全相同</strong>。这是运行时多态的一种体现。  </li><li><strong>重载</strong>的访问修饰符没有限制，可以不同。</li><li>而子类<strong>重写</strong>父类方法时，子类的方法的访问权限<strong>不能低于父类方法</strong>。且父类方法访问修饰符为 <code>private/final/static</code> 时，则子类就不能重写该方法</li><li>重载时返回类型可以不同，而重写时返回类型必须与父类相同或是父类的子类。</li><li>构造方法可以重载，但不能被重写。</li></ul><h3 id="什么是可变长参数？"><a href="#什么是可变长参数？" class="headerlink" title="什么是可变长参数？"></a>什么是可变长参数？</h3><p><strong>可变长参数</strong>（Varargs）是 Java 中的一种语法特性，允许在方法中传递<strong>不定数量</strong>的参数。使用可变长参数时，调用者可以传递任意数量的参数，甚至不传递任何参数。编译器会自动将这些参数转换为数组。  </p><p>且可变长参数必须是方法参数列表中的<strong>最后一个参数</strong>。  </p><p><strong>遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？</strong></p><p>答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。</p><p> <font style="color:#3c3c43;">另外，Java 的可变参数编译后实际会被转换成一个数组，我们看编译后生成的</font> <code>class</code><font style="color:#3c3c43;">文件就可以看出来了。</font></p>]]></content>
    
    
    <categories>
      
      <category>java后端面经</category>
      
      <category>java后端-八股</category>
      
      <category>java-面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java后端面经</tag>
      
      <tag>八股</tag>
      
      <tag>java-面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>订单号全局唯一</title>
    <link href="/2024/11/20/%E8%AE%A2%E5%8D%95%E5%8F%B7%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80/"/>
    <url>/2024/11/20/%E8%AE%A2%E5%8D%95%E5%8F%B7%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>12306项目保证订单号全局唯一的解决方案基于雪花算法。</p><p><font style="background-color:rgb(253, 253, 254);">雪花算法是一种分布式ID生成算法。主要功能是在分布式系统中生成全局唯一的ID，并且这些ID是按照时间有序递增的，索引效率高。</font></p><p><font style="background-color:rgb(253, 253, 254);">雪花算法使用一个64位的二进制数字作为ID，这64位被分割成四个部分：</font></p><ol><li><strong><font style="background-color:rgb(253, 253, 254);">符号位（1位）</font></strong><font style="background-color:rgb(253, 253, 254);">：最高位是符号位，始终为0，用于标识ID是正数。</font></li><li><strong><font style="background-color:rgb(253, 253, 254);">时间戳（41位）</font></strong><font style="background-color:rgb(253, 253, 254);">：时间戳41位，精确到毫秒级，可以支持69年。</font></li><li><strong><font style="background-color:rgb(253, 253, 254);">工作机器ID（10位）</font></strong><font style="background-color:rgb(253, 253, 254);">：标识位有10位，可以进一步细分为5位数据中心ID和5位工作机器ID，以支持最多32个数据中心和每个数据中心最多32个工作节点。</font></li><li><strong><font style="background-color:rgb(253, 253, 254);">序列号（12位）</font></strong><font style="background-color:rgb(253, 253, 254);">：序列号占12位，用于标识同一毫秒内生成的不同ID，支持每个节点每毫秒产生4096个唯一的ID。</font></li></ol><p>12306项目中订单ID也是由几个部分拼接而成</p><p>以毫秒为单位获取当前的时间戳，再减去一个固定的起始时间戳，得到ID的时间戳部分</p><p><font style="background-color:rgb(253, 253, 254);">每个节点在生成ID时都会有一个唯一的节点ID，这个节点ID存放在 Redis。节点ID在最终生成的ID中占据固定的位数为5位，最多支持32个不同的节点。</font></p><p>在同一毫秒内生成多个ID时，通过序列号来区分。</p><p>序列号在最终生成的ID中占据固定的位数为7位，意味着每个毫秒内最多可以生成128个不同的ID。</p><p>序列号在每个毫秒开始时重置为0，并在每次调用生成ID方法时递增。如果在同一毫秒内生成的ID数量超过了序列号的最大值，则序列号会循环回到0，并且等待到下一个毫秒再生成新的ID，以避免重复。</p><p>最后拼接订单ID时，</p><p><font style="background-color:rgb(253, 253, 254);">时间戳需要向左移动 12 位来腾出足够的空间存储5位节点ID和7位序列号，节点ID左移7位，通过位或运算（|），可以将左移后的时间戳、节点 ID和序列号组合成一个长整型数值，再在末尾拼接用户ID后六位数，</font></p><p><font style="background-color:rgb(253, 253, 254);">组成了全局唯一订单号。</font></p>]]></content>
    
    
    <categories>
      
      <category>java后端面经</category>
      
      <category>java后端-项目</category>
      
      <category>12306</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java后端面经</tag>
      
      <tag>项目</tag>
      
      <tag>12306</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分库分表</title>
    <link href="/2024/11/20/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <url>/2024/11/20/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="12306为什么要分库分表"><a href="#12306为什么要分库分表" class="headerlink" title="12306为什么要分库分表"></a>12306为什么要分库分表</h2><p><font style="background-color:rgb(253, 253, 254);">12306选择分库分表是为了应对高并发的写入请求和数据量增长带来的挑战，提高系统的写入性能和查询性能。</font></p><ol><li><strong><font style="background-color:rgb(253, 253, 254);">写入压力分散</font></strong><font style="background-color:rgb(253, 253, 254);">：在高并发场景下，单一数据库可能无法承受大量的写入请求，导致性能瓶颈。通过分库，可以将数据按照一定规则拆分到多个数据库中，每个数据库只处理部分数据的写入请求。这样，每个数据库所承受的写入压力被大大降低，从而提高了整体的写入性能。</font></li><li><strong>存储压力分散和提高查询性能</strong>：随着12306项目的数据量的不断增加，单一数据库的存储和查询性能可能逐渐下降。此时，可以将数据按照一定的规则拆分到多个表中，每个表存储部分数据，从而分散数据的存储压力，<font style="background-color:rgb(253, 253, 254);">使每个表的查询范围缩小，</font>提高查询性能。</li></ol><p><strong><font style="color:rgb(5, 7, 59);"></font></strong></p><h2 id="分库分表带来的问题"><a href="#分库分表带来的问题" class="headerlink" title="分库分表带来的问题"></a>分库分表带来的问题</h2><h3 id="读请求扩散问题"><a href="#读请求扩散问题" class="headerlink" title="读请求扩散问题"></a><font style="background-color:rgb(253, 253, 254);">读请求扩散问题</font></h3><p><font style="background-color:rgb(253, 253, 254);">在某些场景下（如用户登录使用电话号码登录），由于无法确定用户的分片键，不知道具体查询哪个数据库，可能导致读请求需要扫描多个数据库或表以查找数据。</font></p><p><font style="background-color:rgb(253, 253, 254);">这将大大增加系统的查询负载和响应时间，严重时可能导致登录超时等问题。</font></p><h3 id="全局唯一性ID问题"><a href="#全局唯一性ID问题" class="headerlink" title="全局唯一性ID问题"></a><font style="background-color:rgb(253, 253, 254);">全局唯一性ID问题</font></h3><p><font style="color:rgb(77, 77, 77);">在之前的单库环境时，对于一张表的主键通常会选用整数型字段，然后通过数据库的自增机制来保证唯一性，但在水平分库多节点的情况时，假设还是以数据库自增机制来维护主键唯一性，可能会导致多个库中出现</font><font style="color:rgb(77, 77, 77);">ID</font><font style="color:rgb(77, 77, 77);">相同、数据不同的情况。</font></p><p><font style="color:rgb(77, 77, 77);"></font></p><h2 id="用户分块分表如何实现"><a href="#用户分块分表如何实现" class="headerlink" title="用户分块分表如何实现"></a>用户分块分表如何实现</h2><h3 id="使用ShardingSphere-JDBC对用户表进行分库分表"><a href="#使用ShardingSphere-JDBC对用户表进行分库分表" class="headerlink" title="使用ShardingSphere-JDBC对用户表进行分库分表"></a>使用ShardingSphere-JDBC对用户表进行分库分表</h3><p><font style="color:rgb(51, 51, 51);">引入 ShardingSphere-JDBC 依赖</font></p><p><font style="color:rgb(51, 51, 51);">在配置文件上定义分片规则后，就可以使用数据库分库分表了。</font></p><p><font style="color:rgb(77, 77, 77);"></font></p><h3 id="综合考虑使用username作为分库分表的分片键"><a href="#综合考虑使用username作为分库分表的分片键" class="headerlink" title="综合考虑使用username作为分库分表的分片键"></a>综合考虑使用username作为分库分表的分片键</h3><p><strong><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">从查询优化来看</font></strong><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">：</font><font style="background-color:rgb(253, 253, 254);">username</font><font style="background-color:rgb(253, 253, 254);">是用户登录和查询个人信息时常用的字段。将其作为分片键，可以使得相关的查询操作能够直接定位到特定的分片上，从而减少了跨分片查询的需求，提高了查询效率。</font></p><p><strong><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">从避免热点数据来看</font></strong><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">：</font><font style="background-color:rgb(253, 253, 254);">username</font>&#96;<font style="background-color:rgb(253, 253, 254);">通常具有唯一性和较高的随机性，这有助于保证数据在各个分片上的均匀分布。这样可以避免出现某个分片上的数据过于集中，导致热点问题和性能瓶颈。</font></p><p><strong><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">从稳定性来看</font></strong><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">：</font><font style="background-color:rgb(253, 253, 254);">一旦选择了分片键，它应该是不可变的。</font><font style="background-color:rgb(253, 253, 254);">username</font>&#96;<font style="background-color:rgb(253, 253, 254);">在用户注册后通常不会发生变化，因此满足这一要求。这保证了分片策略的稳定性和可靠性。</font></p><h3 id="使用分库分表策略对用户表进行拆分"><a href="#使用分库分表策略对用户表进行拆分" class="headerlink" title="使用分库分表策略对用户表进行拆分"></a>使用分库分表策略对用户表进行拆分</h3><ul><li><font style="background-color:rgb(253, 253, 254);">计算用户username的哈希值。</font></li><li><font style="background-color:rgb(253, 253, 254);">使用哈希值对</font><font style="background-color:rgb(253, 253, 254);">sharding-count</font><font style="background-color:rgb(253, 253, 254);">（总分片数）取模，得到一个表分片索引。</font></li><li><font style="background-color:rgb(253, 253, 254);">根据索引选择目标表分片。</font></li><li><font style="background-color:rgb(253, 253, 254);">再除以一个库中分片数，得到要分配库的数字。</font></li></ul><p><font style="background-color:rgb(253, 253, 254);">比如总分片数是32，一个库中分片数是16，可以得到分配的库的数字是0和1，加上前缀就是分到的数据库的名字。</font></p><h2 id="订单号分库分表如何实现"><a href="#订单号分库分表如何实现" class="headerlink" title="订单号分库分表如何实现"></a><font style="color:rgb(77, 77, 77);">订单号分库分表如何实现</font></h2><p>计划订单分库分表的基本查询条件是用户要能查看自己的订单，另外，也要支持订单号精准查询。</p><p><font style="color:rgb(77, 77, 77);">这样的话，就需要按照两个字段当做分片键，这也就意味着每次查询时需要带着用户和订单两个字段，非常的不方便。</font></p><p><font style="color:rgb(77, 77, 77);">因此我们设计一个字段分库分表，查询时有用户id和订单号任意一个就能精准查询，而不导致读扩散问题</font></p><p><font style="color:rgb(77, 77, 77);">这里我们用基因算法解决以上问题。</font></p><p><font style="color:rgb(77, 77, 77);">当我们创建订单号时，将用户id后六位数加在订单号后面，这样订单号和用户id后六位数是一样的，</font></p><p><font style="color:rgb(77, 77, 77);">分库分表的时候，如果SQL字段有用户id，对用户id后六位数取模，得到要分配的</font><font style="background-color:rgb(253, 253, 254);">目标表。</font></p><p><font style="background-color:rgb(253, 253, 254);">如果没有用户id，就用订单号后六位数字取模，得到要分配的目标表。</font></p><p><font style="background-color:rgb(253, 253, 254);">因为</font><font style="color:rgb(77, 77, 77);">订单号和用户id后六位数是一样的，</font><font style="background-color:rgb(253, 253, 254);">查询时， 只要带有任意这两个字段其一，都能根据后六位数找到本人订单分配表的位置</font><font style="color:rgb(77, 77, 77);">。</font></p><p><font style="color:rgb(77, 77, 77);"></font></p><p><strong>乘车人如何查询本人订单</strong></p><p><font style="background-color:rgb(253, 253, 254);">12306系统中，一个账号可以为多人，也就是多位乘车人，购买车票。购票时，乘车人可能还没有12306账号。</font></p><p><font style="background-color:rgb(253, 253, 254);">乘车人注册12306账号后，能够通过“本人车票”功能查看自己出行的车票数据记录。</font></p><p><font style="color:rgb(77, 77, 77);">因为证件号是乘车人唯一标识，因此需要通过乘车人的证件号查询本人订单。</font></p><p><font style="color:rgb(77, 77, 77);">又因为订单表分片键并非证件号ID，直接查找会导致”读请求扩散问题”，因此我们需创建路由表，</font><font style="background-color:rgb(253, 253, 254);">通过证件号绑定订单号。</font></p><p><font style="background-color:rgb(253, 253, 254);">路由表的分库分表规则是按照证件号进行 HASH_MOD 。</font></p><p><font style="background-color:rgb(253, 253, 254);">当乘车人查询本人车票时</font></p><p><font style="background-color:rgb(253, 253, 254);">先按照本人证件号分库分表规则得到要查询的路由表，再根据证件号得到对应的订单号集合，</font></p><p><font style="background-color:rgb(253, 253, 254);">根据订单号，通过基因算法得到分配的订单表和订单明细表。</font></p><p><font style="background-color:rgb(253, 253, 254);">再根据订单号得到订单数据，根据订单号和乘车人证件号得到订单明细数据，最后封装返回这些数据。</font></p><p><font style="color:rgb(77, 77, 77);"></font></p><p><font style="color:rgb(77, 77, 77);"></font></p><p><font style="color:rgb(77, 77, 77);"></font></p><p><font style="color:rgb(77, 77, 77);"></font></p><p><font style="color:rgb(77, 77, 77);"></font></p><p><font style="color:rgb(77, 77, 77);"></font></p><p><font style="color:rgb(77, 77, 77);"></font></p><p><font style="color:rgb(77, 77, 77);"></font></p>]]></content>
    
    
    <categories>
      
      <category>java后端面经</category>
      
      <category>java后端-项目</category>
      
      <category>12306</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java后端面经</tag>
      
      <tag>项目</tag>
      
      <tag>12306</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>缓存一致性的实现</title>
    <link href="/2024/11/20/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/11/20/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p><font style="background-color:rgb(253, 253, 254);">缓存一致性是指缓存中的数据与数据库之间的数据保持一致，确保用户读取到的是最新、最准确的数据。</font></p><p><font style="background-color:rgb(253, 253, 254);">在分布式系统中，由于多个节点可能同时访问和修改数据，因此保证缓存一致性非常重要</font></p><p><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);"></font></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><font style="background-color:rgb(253, 253, 254);">解决方案</font></h2><p><font style="background-color:rgb(253, 253, 254);">当数据更新时，我们最好删除缓存，下一次查询缓存时会出现未命中，这时需要重新读取一次数据库并加载到缓存中，这时缓存中的数据就是最新的数据。</font></p><p><font style="background-color:rgb(253, 253, 254);">如果直接更新缓存可能会涉及复杂的逻辑和额外的开销，影响缓存服务器的性能</font></p><p><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);"></font></p><p><font style="background-color:rgb(253, 253, 254);">如果先删缓存，再更新数据库，可能会出现一些问题：</font></p><p><font style="background-color:rgb(253, 253, 254);">线程A删除缓存后，线程B读取到旧数据并更新到缓存中，而线程A随后更新数据库，导致缓存中存储了旧数据。</font></p><p><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);"></font></p><p>如果先更新数据库再删除缓存，也有可能出现一些问题：</p><p>在线程A更新数据库和删除缓存之间，可能有线程B读取到了缓存中的旧数据。但最终缓存与数据库的数据是一致的，并且都是最新的。</p><p>经过对比可以发现，</p><p>如果先删除缓存，再更新数据库，如果没有及时更新，可能会导致缓存长时间地储存旧数据。对业务影响较大</p><p>而先更新数据库，再删除缓存，只存在一个很小周期的缓存与数据库不一致的情况，因此，对于一致性要求不是很高的业务可以选择先更新数据库，再删除缓存，保证缓存一致性。</p><h2 id="列车余票如何保障缓存数据库一致性"><a href="#列车余票如何保障缓存数据库一致性" class="headerlink" title="列车余票如何保障缓存数据库一致性"></a><font style="color:rgb(38, 38, 38);">列车余票如何保障缓存数据库一致性</font></h2><p>但是先更新数据库，再删除缓存，如果出现删除缓存失败的情况，缓存中储存的还是旧数据，就会出现缓存数据库不一致的情况，并不能保证系统的高可用。</p><p>因此像列车余票扣减这种对一致性敏感的业务，最好还是通过 Binlog 异步更新列车缓存，实现缓存一致性。</p><h3 id="一、利用Binlog异步更新缓存"><a href="#一、利用Binlog异步更新缓存" class="headerlink" title="一、利用Binlog异步更新缓存"></a><font style="background-color:rgb(253, 253, 254);">一、利用Binlog异步更新缓存</font></h3><ol><li><strong><font style="background-color:rgb(253, 253, 254);">Binlog记录数据变更</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li><font style="background-color:rgb(253, 253, 254);">当列车余票数据在数据库中发生变化时（如用户购票导致余票减少），MySQL会将这一变更记录到Binlog日志中。</font></li></ul></li><li><strong><font style="background-color:rgb(253, 253, 254);">Canal监听Binlog</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li><font style="color:rgb(51, 51, 51);">‌Canal是一个基于</font><a href="https://www.baidu.com/s?sa=re_dqa_generate&wd=MySQL&rsv_pq=8ebb7bea0376a922&oq=Canal%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%AD%E9%97%B4%E4%BB%B6&rsv_t=1de1WUCSFGRtk/sivOAxZPZ8SFt+hjnkvhuapaTdWPtY4Qtz3RKHZbG6tWP55a7YZRAKl+6GePK6&tn=39042058_26_oem_dg&ie=utf-8"><font style="color:rgb(51, 51, 51);">MySQL</font></a><font style="color:rgb(51, 51, 51);">增量日志解析的中间件，</font><font style="background-color:rgb(253, 253, 254);">通过监听Binlog的变化，可以实时地解析出Binlog中的数据变更信息。</font></li></ul></li><li><strong><font style="background-color:rgb(253, 253, 254);">异步更新缓存</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li><font style="background-color:rgb(253, 253, 254);">然后Canal将解析出的数据变更信息发送到消息队列中。</font></li><li><font style="background-color:rgb(253, 253, 254);">购票模块中的缓存同步服务 订阅消息队列中的消息，并根据消息中的数据变更信息，异步地更新缓存中的数据。例如，如果数据库中某趟列车的余票减少了，缓存同步服务就会相应地减少缓存中该趟列车的余票数量。</font></li></ul></li></ol><h3 id="二、优势分析"><a href="#二、优势分析" class="headerlink" title="二、优势分析"></a><font style="background-color:rgb(253, 253, 254);">二、优势分析</font></h3><ol><li><strong><font style="background-color:rgb(253, 253, 254);">高可靠性</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li><font style="background-color:rgb(253, 253, 254);">通过消息队列的持久化机制和重试机制，可以确保数据变更信息能够可靠地传递到缓存系统，并成功地更新缓存中的数据。即使缓存更新失败，系统也能够在后续的重试中成功更新。</font></li></ul></li><li><strong><font style="background-color:rgb(253, 253, 254);">实时性高</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li>由于Binlog的写入和监听都是异步进行的，并且这些过程通常具有较高的处理速度，因此可以确保缓存中的数据与数据库中的数据之间的延迟非常小。</li></ul></li><li><strong><font style="background-color:rgb(253, 253, 254);">自动化与减少人为错误</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li><font style="background-color:rgb(253, 253, 254);">因为Binlog更新缓存的过程是自动化的，不需要人工干预或额外的触发机制。这大大减少了由于人为错误或系统延迟导致的缓存更新不及的问题。</font></li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以在对一致性要求不是很高的业务，可以选择先更新数据库，再删除缓存。</p><p>像列车余票扣减这种对一致性敏感的业务，最好还是通过 Binlog 异步更新列车余票缓存，实现缓存一致性。</p>]]></content>
    
    
    <categories>
      
      <category>java后端面经</category>
      
      <category>java后端-项目</category>
      
      <category>12306</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java后端面经</tag>
      
      <tag>项目</tag>
      
      <tag>12306</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双重判定锁解决缓存击穿</title>
    <link href="/2024/11/20/%E5%8F%8C%E9%87%8D%E5%88%A4%E5%AE%9A%E9%94%81%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/"/>
    <url>/2024/11/20/%E5%8F%8C%E9%87%8D%E5%88%A4%E5%AE%9A%E9%94%81%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h2><p>热点数据过期导致大量的请求会同时查询后端数据库。</p><p>对于一个之前从未被请求过的数据，当它第一次被请求时，缓存中没有这个数据，从而导致请求穿透到后端存储。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="设置热点数据永不过期："><a href="#设置热点数据永不过期：" class="headerlink" title="设置热点数据永不过期："></a>设置热点数据永不过期：</h3><p>对于一些热点数据，可以将其设置永不过期</p><p><font style="background-color:rgb(253, 253, 254);">但是这些数据将长期占据缓存空间，可能导致缓存资源无法被有效利用。如果后台数据库中的数据发生变化，而缓存中的数据未能及时更新，就会导致数据不一致的问题。</font></p><h3 id="使用互斥锁："><a href="#使用互斥锁：" class="headerlink" title="使用互斥锁："></a>使用互斥锁：</h3><p>在获取数据时，使用分布式锁（如 Redis 的分布式锁）来控制同时只有一个请求可以去后端获取数据，其他请求需要等待锁释放。这样可以防止多个请求同时穿透到后端存储，有效地避免了缓存击穿问题。</p><p>但还有一个问题就是，假如 有1w 的请求读取一个缓存，只有一个线程会执行逻辑请求数据库并放入缓存。剩下的请求全部在等待获取分布式锁。但即使剩下的请求获取到了锁，还是会继续请求数据库。</p><p>这会对数据库造成无用的性能浪费，因为这 100w 的请求，只有第一次是有效的。</p><p>而且还会造成用户响应时间变长，接口吞吐量下降。</p><p>因此我们可以做双重判断</p><p>获取分布式锁后，在查询数据库之前，<strong>再次检查一下缓存中是否存在数据</strong>。如果缓存中存在数据，说明之前已经有线程将数据库中的数据加载到缓存中了，不需要继续从数据库中读取，直接返回缓存中的数据；如果不存在，才继续执行查询数据库的操作。</p><p>这样不仅<font style="background-color:rgb(253, 253, 254);">减少数据库访问压力，还降低用户响应时间</font></p>]]></content>
    
    
    <categories>
      
      <category>java后端面经</category>
      
      <category>java后端-项目</category>
      
      <category>12306</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java后端面经</tag>
      
      <tag>项目</tag>
      
      <tag>12306</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决注册缓存穿透</title>
    <link href="/2024/11/20/%E8%A7%A3%E5%86%B3%E6%B3%A8%E5%86%8C%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/"/>
    <url>/2024/11/20/%E8%A7%A3%E5%86%B3%E6%B3%A8%E5%86%8C%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h2><p><font style="color:rgb(51, 51, 51);">在高并发情况下，可能有大量新用户同时注册，输入的用户名极有可能不存于数据库中，而且这些查询数据库的key也不会被写入缓存，造成每次请求都查不到缓存，直接查询数据库，给数据库造成巨大压力。</font></p><p><font style="color:rgb(51, 51, 51);"></font></p><h2 id="其他解决方案"><a href="#其他解决方案" class="headerlink" title="其他解决方案"></a><font style="color:rgb(51, 51, 51);">其他解决方案</font></h2><h3 id="对不存在的key进行缓存"><a href="#对不存在的key进行缓存" class="headerlink" title="对不存在的key进行缓存"></a><font style="color:rgb(51, 51, 51);">对不存在的key进行缓存</font></h3><p><font style="color:rgb(51, 51, 51);">对不存在的 Key 进行缓存，值设为 Null，并设置短暂过期时间，如 60 秒。</font></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a><font style="color:rgb(51, 51, 51);">问题</font></h4><p><font style="color:rgb(51, 51, 51);">对用户体验不好，假如有一个人注册了a名字，那别人在过期时间都不能注册这名字</font></p><p><font style="color:rgb(51, 51, 51);">而且</font><strong><font style="color:rgb(51, 51, 51);">如果同时有大量并发请求查询不同的名字，数据库还是会秒挂</font></strong></p><p><font style="color:rgb(51, 51, 51);"></font></p><h3 id="Redis-Set-存储已注册用户名"><a href="#Redis-Set-存储已注册用户名" class="headerlink" title=" Redis Set 存储已注册用户名"></a><font style="color:rgb(51, 51, 51);"> Redis Set 存储已注册用户名</font></h3><p><font style="color:rgb(51, 51, 51);">使用确定的数据结构如 Redis 的 Set 集合来存储已注册用户名，判断时检查是否在集合内。</font></p><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a><font style="color:rgb(51, 51, 51);">问题</font></h4><p><font style="color:rgb(51, 51, 51);">永久存储十几亿的用户名到 Redis 缓存中显然不太现实，因为这会</font><strong><font style="color:rgb(51, 51, 51);">占用大量的内存资源。</font></strong></p><p><font style="color:rgb(51, 51, 51);">即使是临时存储，注册用户名还是很有可能在缓存中查询不到数据，</font><strong><font style="color:rgb(51, 51, 51);">仍然无法避免查询数据库的场景。</font></strong></p><p><font style="color:rgb(51, 51, 51);">即使进行分片，也会增加系统的复杂度。</font></p><p><font style="color:rgb(51, 51, 51);">由于该方案占用内存较多且复杂度较高，因此不适合实际应用。</font></p><p><font style="color:rgb(51, 51, 51);"></font></p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a><font style="color:rgb(51, 51, 51);">分布式锁</font></h3><p><font style="color:rgb(51, 51, 51);">针对高并发注册场景，可以先查询缓存，如果不命中则使用分布式锁来保证只有一个线程访问数据库。</font></p><h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a><font style="color:rgb(51, 51, 51);">问题</font></h4><p><font style="color:rgb(51, 51, 51);">虽然一定程度上可以解决缓存穿透问题，但是如果在用户注册高峰期，只有一个线程访问数据库，这可能会导致大量用户的注册请求缓慢或超时，</font><strong><font style="color:rgb(51, 51, 51);">对用户的使用体验来说并不友好。</font></strong></p><p><font style="color:rgb(51, 51, 51);"></font></p><h2 id="12306-解决注册穿透方案"><a href="#12306-解决注册穿透方案" class="headerlink" title="12306 解决注册穿透方案"></a><font style="color:rgb(51, 51, 51);">12306 解决注册穿透方案</font></h2><h3 id="12306如何解决用户注册缓存穿透问题？"><a href="#12306如何解决用户注册缓存穿透问题？" class="headerlink" title="12306如何解决用户注册缓存穿透问题？"></a>12306如何解决用户注册缓存穿透问题？</h3><p><strong><font style="color:rgb(51, 51, 51);">使用布隆过滤器，将所有已注册的用户名存入布隆过滤器，查询时先判断该用户名是否在布隆过滤器中，不在的一定不存在，避免直接查询数据库。</font></strong></p><p><font style="color:rgb(51, 51, 51);">但是如果用户注销了账号，该用户名就可以再次被使用。然而，布隆过滤器由于无法删除元素，因此无法处理这种情况。</font></p><p><font style="color:rgb(51, 51, 51);">为此，我们可以用Redis Set结构储存已注销的用户名。</font></p><p><font style="color:rgb(51, 51, 51);">当其他用户查询用户名是否已被使用时，首先检查布隆过滤器是否包含该用户名。</font></p><p>如果布隆过滤器不存在这个名字，说明未被注册，返回成功</p><p>如果布隆过滤器存在此名字，<font style="color:rgb(51, 51, 51);">进一步检查Redis Set结构中是否包含该用户名。如果有，则代表用户名虽然已被注册但是后来又被注销，可以使用此用户名，返回成功。</font></p><p><font style="color:rgb(51, 51, 51);">如果不存在，则代表该用户名在使用中，尚未注销，因此不可用，返回失败。</font></p><h3 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h3><p><font style="color:rgb(51, 51, 51);">如果用户频繁申请账号再注销，可能导致用户注销可复用的 Username Redis Set 结构变得庞大，增加了存储和查询的负担。</font></p><p><font style="color:rgb(51, 51, 51);">为了防止这种情况，我采取了以下解决方案：</font></p><ol><li><font style="color:rgb(51, 51, 51);">异常行为限制：每次用户注销时，记录用户的证件号，并限制证件号仅可用于注销五次。超过这个限制的次数，将禁止该证件号再次用于注册账号。</font></li><li><font style="color:rgb(51, 51, 51);">缓存分片处理：对Set 结构进行分片，根据用户名的 HashCode 进行取模操作，将数据分散存储在 1024 个 Set 结构中，从而有效防止Redis 大 Key 问题。</font></li></ol>]]></content>
    
    
    <categories>
      
      <category>java后端面经</category>
      
      <category>java后端-项目</category>
      
      <category>12306</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java后端面经</tag>
      
      <tag>项目</tag>
      
      <tag>12306</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2024/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p><font style="background-color:rgb(253, 253, 254);">在12306项目中，购票请求的校验逻辑通常可能非常复杂，包含多种不同的验证步骤，如用户身份验证、余额检查、购票数量限制、行程冲突检查等。传统的做法可能是将这些验证逻辑顺序地写在一个大方法中，这样不仅导致代码臃肿、难以维护，而且违反了开闭原则。每次需要添加新的验证步骤时，都需要修改现有的代码。</font></p><p><font style="background-color:rgb(253, 253, 254);">为了解决这个问题，我们可以使用责任链设计模式。责任链模式是一种行为设计模式，它允许你将请求沿着处理者链进行传递。每个处理者都可以对请求进行处理，也可以将请求传递给链中的下一个处理者。这样，你可以在不修改现有代码的情况下添加新的处理步骤，从而提高了代码的扩展性和可维护性。</font></p><p><font style="background-color:rgb(253, 253, 254);">在12306项目中，我们可以将购票验证逻辑拆分成多个独立的验证处理器（Handler），每个处理器负责一种或多种验证逻辑。然后，将这些处理器按照特定的顺序连接起来，形成一个责任链。当用户发起购票请求时，请求会沿着这个责任链进行传递，每个处理器都会根据自己的职责对请求进行验证。</font></p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p><font style="background-color:rgb(253, 253, 254);">在12306项目中，列车余票缓存的更新是通过监听数据库的Binlog变更来实现的。Canal作为中间件，负责将Binlog的变更内容推送到指定的RocketMQ Topic中。而RocketMQ消费者则负责监听这些消息队列，以实时更新列车余票缓存。</font></p><p><font style="background-color:rgb(253, 253, 254);">当需要监听多个表时，为了高效地分发和处理这些Binlog变更数据，12306项目采用了策略模式。</font></p><p><font style="background-color:rgb(253, 253, 254);">对于每个需要监听的表，都实现了一个对应的策略类，这些类实现了策略接口。在每个策略类中，根据表的特点和业务需求，编写了具体的处理逻辑。</font></p><p><font style="background-color:rgb(253, 253, 254);">当Canal将Binlog的变更内容推送到RocketMQ Topic时，相关消费者会监听这些消息。它会根据消息中的表名称，通过策略模式找到对应的策略实现类，并调用其处理方法来处理Binlog变更数据。</font></p><p><font style="background-color:rgb(253, 253, 254);">如果未来需要监听更多的表，只需要添加新的策略类，并实现策略接口中的方法即可。符合开闭原则，提高了代码的可扩展性。</font></p>]]></content>
    
    
    <categories>
      
      <category>java后端面经</category>
      
      <category>java后端-项目</category>
      
      <category>12306</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java后端面经</tag>
      
      <tag>项目</tag>
      
      <tag>12306</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>列车检索</title>
    <link href="/2024/11/20/%E5%88%97%E8%BD%A6%E6%A3%80%E7%B4%A2/"/>
    <url>/2024/11/20/%E5%88%97%E8%BD%A6%E6%A3%80%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="车票搜索为什么用Redis而不是ES"><a href="#车票搜索为什么用Redis而不是ES" class="headerlink" title="车票搜索为什么用Redis而不是ES"></a><font style="color:#262626;">车票搜索为什么用Redis而不是ES</font></h2><p>ElasticSearch 是一款非常强大的开源搜索及分析引擎</p><p>而Redis是一个开源的内存数据结构存储系统</p><p>从实时性能来说，Redis 将数据存储在内存中，因此具有极低的读取延迟，可以快速响应实时查询请求。这对于需要即时更新的列车数据非常重要，确保用户能够获取到最新的车票信息。</p><p>从部署成本来说，Redis是一款轻量级的数据库，内存占用相对较低，可以在较小的硬件配置上运行。相比之下，ElasticSearch集群通常需要更多的资源投入，包括更高的硬件配置和更大的存储空间。</p><p>从搜索条件来说，虽然页面上有很多如车次类型、车次席别、出发车站、到达车站等检索条件，但这些都是在前端进行检索的。真正的查询条件只有出发地、目的地和出发日期，而Redis 的数据模型相对简单，这使得 Redis 适合存储一些搜索条件，如出发地、目的地，可以便快速筛选结果。</p><h2 id="有没有提供检索功能，比如北京到杭州，要有北京西到杭州西，北京东到杭州东，北京西到杭州东？"><a href="#有没有提供检索功能，比如北京到杭州，要有北京西到杭州西，北京东到杭州东，北京西到杭州东？" class="headerlink" title="有没有提供检索功能，比如北京到杭州，要有北京西到杭州西，北京东到杭州东，北京西到杭州东？"></a>有没有提供<strong>检索功能</strong>，比如北京到杭州，要有北京西到杭州西，北京东到杭州东，北京西到杭州东？</h2><p>前端传到后端的请求数据是出发城市，到达城市，及出发日期。</p><p>前请求数据先会经过责任链，检查相关数据是否为空或空的字符串，然后检查出发日期是否正确，出发到达地点是否存在</p><ol><li></li></ol><p>缓存中用Hash结构储存了两个城市的所有车次</p><p>key是火车号-出发站点-达到站点，比如1-北京南-杭州东，代表了由北京南站驶向杭州东站的1号火车。</p><p>value是这个车次的具体信息。</p><p>这个Hash结构的key是出发城市-到达城市</p><p>因此我们可以把北京(出发城市)杭州(到达城市)拼接在一起，然后在缓存中找这个Key对应的Hash结构，就能得到所有由北京(出发城市)驶向杭州(到达城市)的车次及车次部分信息。</p><ol start="2"><li></li></ol><p>如果缓存中没有车次集合信息，就要到数据库中找，用双重判定锁保证只有一个线程可以将数据库中相关信息加载到缓存中，避免多次查询给数据库带来巨大压力。</p><p>然后根据出发城市和到达城市，可以在火车站点关联表中查询所有相关的车次集合，</p><p>比如根据北京-杭州，可以得到1号火车-北京南站-杭州东站，3号火车-北京站-杭州站的两个车次。</p><p>然后遍历这个集合，从缓存或数据库中查找相关列车基本信息，并填充到车次集合中。</p><p>最后将这个车次集合加载到缓存中。</p><ol start="3"><li></li></ol><p>接下来就是查询列车余票信息并填充到车次基本信息中。</p><p>因为列车余票数据是实时变更的，如果存储到基本信息中，就没办法变更了，因此要单独存储。</p><p>遍历所有车次。</p><p>先在缓存中查这个车次的所有座位种类及对应的价格的集合</p><p>然后在缓存中找到所有座位种类对应的数量，然后将这个车次的每个座位种类，数量，价格封装成一个类，并加入集合中，然后将这个集合加入到这个车次基本信息中。</p><p>最后返回车次信息集合。</p>]]></content>
    
    
    <categories>
      
      <category>java后端面经</category>
      
      <category>java后端-项目</category>
      
      <category>12306</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java后端面经</tag>
      
      <tag>项目</tag>
      
      <tag>12306</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>令牌桶限流/防超卖</title>
    <link href="/2024/11/20/%E4%BB%A4%E7%89%8C%E6%A1%B6%E9%99%90%E6%B5%81_%E9%98%B2%E8%B6%85%E5%8D%96/"/>
    <url>/2024/11/20/%E4%BB%A4%E7%89%8C%E6%A1%B6%E9%99%90%E6%B5%81_%E9%98%B2%E8%B6%85%E5%8D%96/</url>
    
    <content type="html"><![CDATA[<h2 id="如何保障购票时系统承载高并发而不出问题？"><a href="#如何保障购票时系统承载高并发而不出问题？" class="headerlink" title="如何保障购票时系统承载高并发而不出问题？"></a>如何保障购票时系统承载高并发而不出问题？</h2><p>对于五一、国庆以及过年这些节日来说，一些热门列车的 TPS 少说有几十万 ，很有可能产生瞬时高并发压垮系统的问题，因此必须要对购票服务限流。</p><p><font style="background-color:rgb(253, 253, 254);">最开始计划采用余票缓存来展示余票数量并实现限流效果。这种方式下，系统会将列车余票数据缓存到内存中，以便快速响应前端查询请求。同时，通过缓存中的余票数量来控制购票请求的并发量，避免系统过载。</font></p><p><font style="background-color:rgb(253, 253, 254);">然而，余票缓存做限流也存在一定的风险。特别是在极端情况下，如扣减余票缓存成功后应用宕机，会导致余票缓存和余票数据库库存不一致。这种情况下，前端查询缓存可能会展示余票为0，但数据库实际仍有余票。这种时候，类似于电商的处理，余票为 0 的记录是不允许用户再提交订单的。为了避免用户因余票数量不准确而无法购票，系统需要采取额外的措施来保障购票流程的顺畅。</font></p><p><font style="background-color:rgb(253, 253, 254);">为了解决这个问题，系统引入了令牌桶限流机制。</font></p><p><font style="background-color:rgb(253, 253, 254);">令牌桶限流是一种常用的限流算法，它通过一个令牌容器来存放令牌，每个令牌代表一张列车余票。用户购票时需要先尝试从令牌容器中扣减令牌。如果扣减成功，表示余票数量充足，用户可以继续进行后续的座位分配和订单创建流程；如果扣减失败，则请求被拒绝，避免了对后端数据库的过度压力。</font></p><p><font style="background-color:rgb(253, 253, 254);">为了进一步提高系统的稳定性和可靠性，系统在令牌桶限流的基础上还增加了二次检查机制。当发现没有剩余可用令牌时，系统会触发一个请求去比对数据库是否还有余票。如果数据库有余票，那么系统会将令牌容器缓存删除，并在下一个用户购票时重新加载。</font></p><p><font style="background-color:rgb(253, 253, 254);">如果我们用了令牌遇到上述极端情况，令牌余量为 0，余票缓存余量正常，数据库正常。这个时候，只要余票缓存不为 0，那么哪怕令牌为空，也可以让用户正常下单，进而触发刷新令牌容器的操作。</font></p><p><font style="background-color:rgb(253, 253, 254);">除此之外，在扣减令牌，分配座位成功后，系统会立即将数据库中的座位状态修改为已锁定，防止其他用户同时购买同一个座位。同时，通过Canal数据库变更监听工具，系统会实时监控到座位状态的变更，并更新余票缓存，确保缓存中的余票数据与数据库保持一致。</font></p><h2 id="令牌桶限流如何实现？"><a href="#令牌桶限流如何实现？" class="headerlink" title="令牌桶限流如何实现？"></a>令牌桶限流如何实现？</h2><h3 id="一、令牌桶的初始化和存储"><a href="#一、令牌桶的初始化和存储" class="headerlink" title="一、令牌桶的初始化和存储"></a><font style="background-color:rgb(253, 253, 254);">一、令牌桶的初始化和存储</font></h3><ol><li><strong><font style="background-color:rgb(253, 253, 254);">令牌桶的创建</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li><font style="background-color:rgb(253, 253, 254);">在Redis中创建一个特定结构的Key，用于存储令牌桶的信息。这个Key由车票服务标识、令牌限流容器的标识以及列车ID信息组成。</font></li></ul></li><li><strong><font style="background-color:rgb(253, 253, 254);">令牌桶的存储</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li><font style="background-color:rgb(253, 253, 254);">令牌桶采用 Hash结构， Key 由此列车出发站，终点站以及座位类型组成，对应的 Value 就是列车座位余量。</font></li><li><font style="background-color:rgb(253, 253, 254);">比如id为2的火车对应的令牌桶，有key为北京南_杭州东_0，对应的val为10，代表由北京南驶向杭州东的2号火车的商务座余票量为10，还有key为北京南_南京南_2 ，val为800，代表由北京南驶向南京南的2号火车的二等座余票量为800。</font></li><li><font style="background-color:rgb(253, 253, 254);">而当购买一张票时，还要扣减中间站点以及沿途各站的余量，</font>比如2号火车的行驶路线由北京南站—南京南站—杭州东站 ，如果用户买了北京南站—杭州东站的火车票，同时也要扣减北京南站—南京南站，南京南站—杭州东站的火车票。</li></ul></li></ol><h3 id="二、令牌获取流程"><a href="#二、令牌获取流程" class="headerlink" title="二、令牌获取流程"></a><font style="background-color:rgb(253, 253, 254);">二、令牌获取流程</font></h3><ol><li><strong><font style="background-color:rgb(253, 253, 254);">令牌容器存在性检查</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li><font style="background-color:rgb(253, 253, 254);">在尝试获取令牌之前，系统首先会检查令牌容器是否在Redis中有效。如果令牌容器失效，系统会重新读取并放入缓存。</font></li></ul></li><li><strong><font style="background-color:rgb(253, 253, 254);">准备Lua脚本执行数据</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li><font style="background-color:rgb(253, 253, 254);">然后系统会准备一系列参数，包括存储Redis Hash结构的Key值、用户购买的出发站点和到达站点、需要扣减的相关列车站点以及座位类型和对应数量，这些参数将被传递给Lua脚本。</font></li></ul></li><li><strong><font style="background-color:rgb(253, 253, 254);">执行Lua脚本获取令牌</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li><font style="background-color:rgb(253, 253, 254);">最后，通过客户端调用 Redis 执行 Lua 脚本。判断当前令牌数是否足够满足用户的请求。如果令牌不足，则直接返回失败，如果足够，扣减出发站点和到达站点以及相关的车站令牌余量</font></li></ul></li><li><strong><font style="background-color:rgb(253, 253, 254);">Lua脚本的原子性</font></strong><font style="background-color:rgb(253, 253, 254);">：</font><ul><li><font style="background-color:rgb(253, 253, 254);">Lua脚本在Redis中的执行是原子性的，保证了在高并发环境下，令牌桶状态的更新和令牌的获取是安全的。</font></li></ul></li></ol><h2 id="如何防止库存超卖"><a href="#如何防止库存超卖" class="headerlink" title="如何防止库存超卖"></a>如何防止库存超卖</h2><p><font style="background-color:rgb(253, 253, 254);">为了防止库存超卖，系统采取了以下措施：</font></p><ol><li><strong><font style="background-color:rgb(253, 253, 254);">令牌桶限流：</font></strong><ul><li><font style="background-color:rgb(253, 253, 254);">通过令牌桶限流机制，确保只有在获取到令牌的情况下，用户才能继续购票流程。</font></li><li><font style="background-color:rgb(253, 253, 254);">令牌的数量与列车座位余量一一对应，从而避免了超卖的情况。</font></li></ul></li><li><strong><font style="background-color:rgb(253, 253, 254);">订单锁定机制：</font></strong><ul><li><font style="background-color:rgb(253, 253, 254);">在扣减令牌、分配座位成功后，系统会立即将数据库中的座位状态修改为已锁定。</font></li><li><font style="background-color:rgb(253, 253, 254);">这一机制防止了其他用户同时购买同一个座位，从而避免了库存超卖的风险。</font></li></ul></li><li><strong><font style="background-color:rgb(253, 253, 254);">缓存与数据库一致性：</font></strong><ul><li><font style="background-color:rgb(253, 253, 254);">通过Canal数据库变更监听工具，系统能够实时监控座位状态的变更，并更新余票缓存。</font></li><li><font style="background-color:rgb(253, 253, 254);">这确保了缓存中的余票数据与数据库保持一致，避免了因缓存不一致而导致的超卖问题。</font></li></ul></li></ol><p><font style="background-color:rgb(253, 253, 254);">通过令牌桶限流机制、订单锁定机制以及缓存与数据库一致性保障等措施，系统能够有效地防止库存超卖问题，确保购票流程在高并发下的顺畅进行。</font></p><p><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);"></font></p><p><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);"></font></p>]]></content>
    
    
    <categories>
      
      <category>java后端面经</category>
      
      <category>java后端-项目</category>
      
      <category>12306</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java后端面经</tag>
      
      <tag>项目</tag>
      
      <tag>12306</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
